%=============================================================================
%=============================================================================

\chapter{The ParFlow System}
\label{The ParFlow System}

The \parflow{} system is still evolving, but here we discuss how to define the problem in
\S~\ref{Defining the Problem}, how to run \parflow{} in
\S~\ref{Running ParFlow}, and options for to visualizing the results in
\S~\ref{Visualizing Output}.  There is also a utility providing a set
of functions for manipulating \parflow{} data.  This utility is discussed in 
\S~\ref{Manipulating Data}.  Lastly, \S~\ref{Test Directory} discusses the
contents of a directory of test problems provided with \parflow{}.

%=============================================================================
%=============================================================================

\section{Defining the Problem}
\label{Defining the Problem}

Defining the problem may involve several steps.
One of these steps may require definition complicated geometries such as hydrostratigraphic layers.
These geometries are then converted to the
\file{.pfsol} file format (\S~\ref{ParFlow Solid Files (.pfsol)})
using the appropriate \pftools{} conversion utility
(\S~\ref{Manipulating Data}).

The "main" \parflow{} input file is the \file{.tcl} file.
This input file is a TCL script with some special routines to
create a database which is used as the input for \parflow{}.
See \S~\ref{Main Input File (.pftcl)} for details on the format
of this file.
The input values into \parflow{} are defined by a key/value pair.  For
each key you provide the associated value using the \code{pfset} command
inside the input script.  To set the computational grid for the problem
you would enter:

\begin{display}\begin{verbatim}
#-----------------------------------------------------------------------------
# Computational Grid
#-----------------------------------------------------------------------------
pfset ComputationalGrid.Lower.X                -10.0
pfset ComputationalGrid.Lower.Y                 10.0
pfset ComputationalGrid.Lower.Z                  1.0
 
pfset ComputationalGrid.DX                       8.89
pfset ComputationalGrid.DY                      10.67
pfset ComputationalGrid.DZ                       1.0
 
pfset ComputationalGrid.NX                      18
pfset ComputationalGrid.NY                      15
pfset ComputationalGrid.NZ                       8

\end{verbatim}\end{display}

The value is normally a single string, double, or integer.  In some cases,
in particular for a list of names, you need to supply a space seperated
sequence.  This can be done using either a double quote or braces.

\begin{display}\begin{verbatim}
pfset Geom.domain.Patches "left right front back bottom top"

pfset Geom.domain.Patches {left right front back bottom top}
\end{verbatim}\end{display}

For commands longer than a single line, the TCL continuation character can be
used, 
\begin{display}\begin{verbatim}
pfset Geom.domain.Patches "very_long_name_1 very_long_name_2 very_long_name_3 \
                           very_long_name_4 very_long_name_5 very_long_name_6"
\end{verbatim}\end{display}


Since the input file is a TCL script you can use any feature of TCL to
define the problem.  This manual will make no effort to teach TCL so
refer to one of the available TCL manuals for more information
(``Practical Programming in TCL and TK'' by Brent Welch \cite{welch.95} 
is a good starting point).  
This is NOT required, you can get along fine without understanding TCL/TK.

Looking at the example programs in the \file{test} directory is one of
the best ways to understand what a \parflow{} input file looks like. See
\S~\ref{Test Directory}.  

%=============================================================================
%=============================================================================

\section{Running ParFlow}
\label{Running ParFlow}

Once the problem input is defined, you need to add a few things to 
the script to make it execute \parflow{}.  First you need to add
the TCL commands to load the \parflow{} command package.

\begin{display}\begin{verbatim}
#
# Import the ParFlow TCL package
#
lappend auto_path $env(PARFLOW_DIR)/bin 
package require parflow
namespace import Parflow::*
\end{verbatim}\end{display}

This loads the \code{pfset} and other \parflow{} commands into the
TCL shell.

Since this is a script you need to actually run \parflow{}. These are
normally the last lines of the input script.

\begin{display}\begin{verbatim}
#-----------------------------------------------------------------------------
# Run and Unload the ParFlow output files
#-----------------------------------------------------------------------------
pfrun default_single
pfundist default_single
\end{verbatim}\end{display}


The \code{pfrun} command runs \parflow{} with the database as it
exists at that point in the file.  The argument is the name to give to
the output files (which will normally be the same as the name of the
script).  Advanced users can set up multiple problems within the input
script by using different output names.  

The \code{pfundist} command takes the output files from the \parflow{}
run and undistributes them.  \parflow{} uses a virtual file system
which allows files to be distributed across the processors.  The
\code{pfundist} takes these files and collapses them into a single
file.  On some machines if you don't do the \code{pfundist} you will
see many files after the run.  Each of these contains the output from
a single node; before attempting using them you should undistribute them.

Since the input file is a TCL script run it using TCL:

\begin{display}\begin{verbatim}
tclsh runname.tcl
\end{verbatim}\end{display}

NOTE: Make sure you are using TCL 8.0 or later.  The script will not
work with earlier releases.

One output file of particular interest is the \file{<run
name>.out.log} file.  This file contains information about the run
such as number of processes used, convergence history of algorithms,
timings and MFLOP rates.  For Richards' equation problems (including overland flow) the \file{<run
name>.out.kinsol.log} file contains the nonlinear convergence information for each timestep.  Additionally, the \file{<run
name>.out.tx} contains all information routed to \file{standard out} of the machine you are running on and often contains error messages and other control information.

\section{Restarting a Run}
\label{Restarting a Run}

A \parflow{} run may need to be restarted because either a
system time limit has been reached, \parflow{} has been prematurely
terminated or the user specifically sets up a problem to run in segments.
In order to restart a run the user needs to know the conditions under which
\parflow{} stopped.  If \parflow{} was prematurely terminated then the
user must examine the output files from the last "timed dump" to see if
they are complete.  If not then those data files should be discarded and the
output files from the next to last "timed dump" will be used in the
restarting procedure.  As an important note, if any set of "timed dump"
files are deleted remember to also delete corresponding lines in the well
output file or recombining the well output files from the individual segments
afterwards will be difficult.  It is not necessary to delete lines from
the log file as you will only be noting information from it.  To summarize,
make sure all the important output data files are complete, accurate and
consistent with each other.

Given a set of complete, consistent output files - to restart a run follow
this procedure :

\begin{enumerate}
   \item Note the important information for restarting :
   \begin{itemize}
      \item Write down the dump sequence number for the last collection of
           ``timed dump'' data.
      \item Examine the log file to find out what real time that "timed dump"
            data was written out at and write it down.
   \end{itemize}
   \item Prepare input data files from output data files :
   \begin{itemize}
      \item Take the last pressure output file before the restart with the sequence number
            from above and format them for regular input using the keys detailed in \S~\ref{Initial Conditions: Pressure} and possibly the \code{pfdist} utility in the input script.
   \end{itemize}
   \item Change the Main Input File \S~\ref{Main Input File (.tcl)} :
   \begin{itemize}
      \item Edit the .tcl file (you may want to save the old one) and
            utilize the pressure initial condition input file option (as referenced above) to specify
             the input files you created above as initial conditions
            for concentrations.
   \end{itemize}
   \item Restart the run :
   \begin{itemize}
      \item Utilizing an editor recreate all the input parameters used
            in the run except for the following two items :
            \begin{itemize}
               \item Use the dump sequence number from step 1
                     as the start\_count.
               \item Use the real time that the dump occured at from step 1
                     as the start\_time.
            \end{itemize}
   \end{itemize}
\end{enumerate}

%=============================================================================
%=============================================================================

\section{Visualizing Output}
\label{Visualizing Output}

While \parflow{} does not have any visualization capabilities built-in, there are a number flexible, free options.  Probably the best option is to use \emph{VisIt}. \emph{VisIt} is a powerful, free, open-source, rendering environment.  It is multiplatform and may be downloaded directly from:
\begin{display}\begin{verbatim}
https://wci.llnl.gov/codes/visit/
\end{verbatim}\end{display}
The most flexible option for using \emph{VisIt} to view \parflow{} output is to write files using the \emph{SILO} format, which is available either as a direct output option (described in \S~\ref{Code Parameters}) or a conversion option using pftools.  Many other output conversion options exist as described in \S~\ref{Manipulating Data} and this allows \parflow{} output to be converted into formats used by almost all visualization software.
%=============================================================================
%=============================================================================

\section{Manipulating Data}
\label{Manipulating Data}

\subsection{Introduction to the \parflow{} TCL commands (PFTCL) }
Several tools for manipulating data are provided in PFTCL command set. 
Tools can be accessed directly from the TCL shell or within a \parflow{} input script. 
In both cases you must first load the \parflow{} package into the TCL shell as follows: 


\begin{display}\begin{verbatim}
#
# To Import the ParFlow TCL package
#
lappend auto_path $env(PARFLOW_DIR)/bin 
package require parflow
namespace import Parflow::*
\end{verbatim}\end{display}

In addition to these methods xpftools provides GUI access to most of these features.  However
the simplest approach is generally to include the tools commands within a tcl script. The 
following section lists all of the available ParFlow TCL commands along with detailed instructions for their use.
\S~ref{PFTCL Commands} provides several examples of pre and post processing using the tools.  In addition, a list of
tools can be obtained by typing ¿pfhelp¿ into a TCL shell after importing ParFlow. Typing ¿pfhelp¿ followed by a 
command name will display a detailed description of the command in question. 


\subsection{PFTCL Commands}
\label{PFTCL Commands}
The table below provides a list of ParFlow commands with short descriptions grouped according to their function. 
The last two columns in this table indicate what examples from \S~\ref{common_pftcl}, if any, the command is used in 
and whether the command is compatible with a terrain following grid domain formulation. 

Detailed descriptions of every command are included below in alphabetical order.
Note that the required inputs are listed following each command. Commands that perform 
operations on data sets will require an identifier for each data set it takes as input. 
Inputs listed in square brackets are optional and do not need to be provided. 

\begin{description}

\item{\begin{verbatim}pfaxpy alpha x y\end{verbatim}}
This command computes y = alpha*x+y where alpha is a scalar and x and y are identifiers 
representing data sets. No data set identifier is returned upon successful completion 
since data set y is overwritten.

\item{\begin{verbatim}pfbfcvel conductivity phead\end{verbatim}}
This command computes the block face centered flow velocity at every grid cell. 
Conductivity and pressure head data sets are given as arguments.   
The output includes x, y, and z velocity components that are appended to the Tcl result.

\item{\begin{verbatim}pfbuilddomain database\end{verbatim}}
This command builds a subgrid array given a ParFlow database that contains the domain 
parameters and the processor topology. 

\item{\begin{verbatim}pfcelldiff datasetx datasety mask\end{verbatim}}
This command computes cell-wise differences of two datasets (diff=datasetx-datasety). 
This is the difference at each individual cell, not over the domain. Datasets must have the same dimensions.

\item{\begin{verbatim}pfcelldiffconst dataset constant mask\end{verbatim}}
This command subtracts a constant value from each (active) cell of dataset (dif=dataset - constant).

\item{\begin{verbatim}pfcelldiv datasetx datasety mask\end{verbatim}}
This command computes the cell-wise quotient of datasetx and datasety (div = datasetx/datasety).
This is the quotient at each individual cell. Datasets must have the same dimensions.

\item{\begin{verbatim}pfcelldivconst dataset constant mask\end{verbatim}}
This command divides each (active) cell of dataset by a constant (div=dataset/constant). 

\item{\begin{verbatim}pfcellmult datasetx datasety mask\end{verbatim}}
This command computes the cell-wise product of datasetx and datasety (mult = datasetx * datasety).
This is the product at each individual cell. Datasets must have the same dimensions.

\item{\begin{verbatim}pfcellmultconst dataset constant mask\end{verbatim}}
This command multiplies each (active) cell of dataset by a constant (mult=dataset * constant). 


\item{\begin{verbatim}pfcellsum datasetp datasetq mask\end{verbatim}}
This command computes the cellwise sum of two datasets (i.e., the sum at each
individual cell, not the sum over the domain). Datasets must have the same
dimensions. 


\item{\begin{verbatim}pfcellsumconst dataset constant mask\end{verbatim}}
This command adds the value of constant to each (active) cell of dataset. 

\item{\begin{verbatim}pfchildD8 dem\end{verbatim}}
This command computes the unique D8 child for all cells. Child[i,j] is the
elevation of the cell to which [i,j] drains (i.e. the elevation of [i,j]'s 
child). If [i,j] is a local minima the child elevation set the elevation of [i,j].

\item{\begin{verbatim}pfcomputebottom mask\end{verbatim}}
This command computes the bottom of the domain based on the mask of active and inactive zones.
The identifier of the data set created by this operation is returned upon successful completion.

\item{\begin{verbatim}pfcomputedomain top bottom\end{verbatim}} This
 command computes a domain based on the top and bottom data sets.  The
 domain built will have a single subgrid per processor that covers the
 active data as defined by the top and botttom.  This domain will more
 closely follow the topology of the terrain than the default single
 computation domain.  

A typical usage pattern for this is to start with a mask file (zeros
 in inactive cells and non-zero in active cells), create the top and
 bottom from the mask, compute the domain and then write out the domain.


\begin{verbatim}

#---------------------------------------------------------
# This example script takes 3 command line arguments
# for P,Q,R and then builds a SAMRAI compatible 
# domain decomposition based off of a mask file.
#---------------------------------------------------------

#---------------------------------------------------------
# Processor Topology
#---------------------------------------------------------

set P  [lindex $argv 0]
set Q  [lindex $argv 1]
set R  [lindex $argv 2]

pfset Process.Topology.P $P
pfset Process.Topology.Q $Q   
pfset Process.Topology.R $R

#---------------------------------------------------------
# Computational Grid
#---------------------------------------------------------
pfset ComputationalGrid.Lower.X                -10.0
pfset ComputationalGrid.Lower.Y                 10.0
pfset ComputationalGrid.Lower.Z                  1.0

pfset ComputationalGrid.DX                       8.8888888888888893
pfset ComputationalGrid.DY                      10.666666666666666
pfset ComputationalGrid.DZ                       1.0

pfset ComputationalGrid.NX                      10
pfset ComputationalGrid.NY                      10
pfset ComputationalGrid.NZ                       8


set mask [pfload samrai.out.mask.pfb]

set top [pfcomputetop $mask]
set bottom [pfcomputebottom $mask]

set domain [pfcomputedomain $top $bottom]

set out [pfprintdomain $domain]

set grid\_file [open samrai_grid.tcl w]
puts $grid_file $out
close $grid_file

#---------------------------------------------------------
# The resulting TCL file samrai_grid.tcl may be read into
# a Parflow input file using ``source samrai_grid.tcl''.
#---------------------------------------------------------
\end{verbatim}

\item{\begin{verbatim}pfcomputetop mask\end{verbatim}} 
This command computes the top of the domain based on the mask of
 active and inactive zones.  This is the land-surface in \code{clm} or
 overland flow simulations.  The identifier of the data set created by
 this operation is returned upon successful completion.

\item{\begin{verbatim}pfcvel conductivity phead\end{verbatim}}
This command computes the Darcy velocity in cells for the conductivity data set
represented by the identifier `conductivity' and the pressure head
data set represented by the identifier `phead'.  (note: This "cell"
is not the same as the grid cells; its corners are defined by the
grid vertices.)  The identifier of the data set created by this
operation is returned upon successful completion.


\item{\begin{verbatim}pfdelete dataset\end{verbatim}}
This command deletes the data set represented by the identifier `dataset'. This
command can be useful when working with multiple datasets / time series, such as
those created when many timesteps of a file are loaded and processed.  Deleting these
datasets in between reads can help with tcl memory management.
        

\item{\begin{verbatim}pfdiffelt datasetp datasetq i j k digits [zero]\end{verbatim}}
This command returns the difference of two corresponding coordinates
from `datasetp' and `datasetq' if the number of digits in agreement
(significant digits) differs by more than `digits' significant
digits and the difference is greater than the absolute zero given     
by `zero'.


\item{\begin{verbatim}pfdist filename \end{verbatim}}
Distribute the file onto the virtual file system. This utility must be used to 
create files which ParFlow can use as input. ParFlow uses a virtual file system 
which allows each node of the parallel machine to read from the input file independently. 
The utility does the inverse of the pfundist command. If you are using a ParFlow binary 
file for input you should do a pfdist just before you do the pfrun. This command
requires that the processor topology and computational grid be set in the input 
file so that it knows how to distribute the data. NOTE: When distributing slope
files the  NZ must be set to 1 to indicate a two dimensional file.  

\item{\begin{verbatim}pfdistondomain filename domain\end{verbatim}}
 Distribute the file onto the virtual file system based on the domain
 provided rather than the processor topology as used by pfdist.  This
 is used by the SAMRAI version of which allows for a more complicated
 computation domain specification with different sized subgrids on
 each processor and allows for more than one subgrid per processor.
  Frequently this will be used with a domain created by the
 pfcomputedomain command.   


\item{\begin{verbatim}pfeffectiverecharge precip et slopex slopey dem\end{verbatim}}
This command computes the effective recharge at every grid cell based on total precipitation
minus evapotranspiration (P-ET)in the upstream area. Effective recharge is consistent with TOPMODEL
definition, NOT local P-ET.   Inputs are total annual (or average annual) precipitation (precip) at each point, 
total annual (or average annual) evapotranspiration (ET) at each point, slope in the x
direction, slope in the y direction and elevation. 

\item{\begin{verbatim}pfenlargebox dataset sx sy sz\end{verbatim}}
This command returns a new dataset which is enlarged to be of the
new size indicated by sx, sy and sz. Expansion is done first in the 
z plane, then y plane and x plane. 

\item{\begin{verbatim}pfextract2Ddomain domain\end{verbatim}} This
 command builds a 2D domain based off a 3D domain.  This can be used
 for a pfdistondomain command for Parflow 2D data (such as slopes and
 soil indices).

\item{\begin{verbatim}pfextracttop top data\end{verbatim}} 
This command computes the top of the domain based on the top of the
 domain and another dataset.  The identifier of the data set created
 by this operation is returned upon successful completion.

\item{\begin{verbatim}pffillflats dem\end{verbatim}} 
This command finds the flat regions in the DEM and eliminates them by 
bilinearly interpolating elevations across flat region.

\item{\begin{verbatim}pfflintslaw dem c p\end{verbatim}}
This command smooths the digital elevation model dem according to Flints Law, with
Flints Law parameters specified by c and p, respectively. Flints Law relates the 
slope magnitude at a given cell to its upstream contributing area: S = c*A**p. In 
this routine, elevations at local minima retain the same value as in the original 
dem. Elevations at all other cells are computed by applying Flints Law recursively 
up each drainage path, starting at its terminus (a local minimum) until a drainage 
divide is reached. Elevations are computed as: 

dem[i,j] = dem[child] + c*(A[i,j]**p)*ds[i,j]

where child is the D8 child of [i,j] (i.e., the cell to which [i,j] drains according
to the D8 method); ds[i,j] is the segment length between the [i,j] and its child; 
A[i,j] is the upstream contributing area of [i,j]; and c and p are constants.


\item{\begin{verbatim}pfflintslawbybasin dem c0 p0 maxiter\end{verbatim}}
This command smooths the digital elevation model (dem) using  the same approach
as "pfflints law". However here the c and p parameters are fit for each basin separately.  
The Flint¿s Law parameters are calculated for the provided digital elevation model dem 
using the iterative Levenberg-Marquardt method of non-linear least squares minimization, 
as in "pfflintslawfit". The user must provide initial estimates of c0 and p0; results are
not sensitive to these initial values. The user must also specify the maximum number of 
iterations as maxiter.

\item{\begin{verbatim}pfflintslawfit dem c0 p0 maxiter\end{verbatim}}
This command fits Flint's Law parameters c and p for the provided digital elevation 
model dem using the iterative Levenberg-Marquardt method of non-linear least squares 
minimization. The user must provide initial estimates of c0 and p0; results are not
sensitive to these initial values. The user must also specify the maximum number of 
iterations as maxiter. Final values of c and p are printed to the screen, and a 
dataset containing smoothed elevation values is returned. Smoothed elevations are 
identical to running pfflintslaw for the final values of c and p. Note that dem 
must be a ParFlow dataset and must have the correct grid information -- dx, dy, nx, 
and ny are used in parameter estimation and Flint's Law calculations. If gridded 
elevation values are read in from a text file (e.g., using pfload's simple ascii 
format), grid information must be specified using the pfsetgrid command. 

\item{\begin{verbatim}pfflux conductivity hhead\end{verbatim}}
This command computes the net Darcy flux at vertices for the
conductivity data set `conductivity' and the hydraulic head data      
set given by `hhead'.  An identifier representing the flux computed   
will be returned upon successful completion.
    
\item{\begin{verbatim}pfgetelt dataset i j k\end{verbatim}}
This command returns the value at element (i,j,k) in data set         
`dataset'.  The i, j, and k above must range from 0 to (nx - 1), 0 to 
(ny - 1), and 0 to (nz - 1) respectively.  The values nx, ny, and nz
are the number of grid points along the x, y, and z axes respectively.
The string `dataset' is an identifier representing the data set whose
element is to be retrieved.

\item{\begin{verbatim}pfgetgrid dataset\end{verbatim}}
This command returns a description of the grid which serves as the
domain of data set `dataset'.  The format of the description is given 
below.
\begin{itemize}
\item{\begin{verbatim}(nx, ny, nz)\end{verbatim}
The number of coordinates in each direction.}
\item{\begin{verbatim}(x, y, z)\end{verbatim}The origin of the grid.}
\item{\begin{verbatim}(dx, dy, dz)\end{verbatim}The distance between each
coordinate in each direction.}
\end{itemize}
The above information is returned in the following Tcl list format:
{nx ny nz} {x y z} {dx dy dz}
           
\item{\begin{verbatim}pfgetlist dataset\end{verbatim}}
This command returns the name and description of a dataset if an argument is provided.  
If no argument is given, then all of the data set names followed by their descriptions 
is returned to the TCL interpreter. If an argument (dataset) is given, it should be the 
it should be the name of a loaded dataset. 

\item{\begin{verbatim}pfgetstats dataset\end{verbatim}}
This command calculates the following statistics for the data set represented by the 
identifier ¿dataset¿:minimum, maximum, mean, sum, variance, and standard deviation. 

\item{\begin{verbatim}pfgetsubbox dataset il jl kl iu ju ku\end{verbatim}}
This command computes a new dataset with the subbox starting at il, jl, kl and going to iu, ju, ku.
    

\item{\begin{verbatim}pfgridtype gridtype\end{verbatim}}
This command sets the grid type to either cell centered if `gridtype'
is set to `cell' or vetex centered if `gridtype' is set to `vertex'.
If no new value for `gridtype' is given, then the current value of
`gridtype' is returned.  The value of `gridtype' will be returned upon
successful completion of this command.


\item{\begin{verbatim}pfgwstorage mask porosity pressure saturation specific_storage\end{verbatim}}
This command computes the sub-surface water storage (compressible and incompressible components) 
based on mask, porosity, saturation, storativity and pressure fields, similar to pfsubsurfacestorage,
but only for the saturated cells. 

\item{\begin{verbatim}pfhelp [command]\end{verbatim}}
This command returns a list of pftools commands. If a command is provided it gives a detailed
description of the command and the necessary inputs. 

\item{\begin{verbatim}pfhhead phead\end{verbatim}}
This command computes the hydraulic head from the pressure head       
represented by the identifier `phead'.  An identifier for the 
hydraulic head computed is returned upon successful completion.

\item{\begin{verbatim}pfhydrostatic wtdepth top mask\end{verbatim}}
Compute hydrostatic pressure field from water table depth

\item{\begin{verbatim}pflistdata dataset\end{verbatim}}
This command returns a list of pairs if no argument is given.  The
first item in each pair will be an identifier representing the data   
set and the second item will be that data set's label.  If a data     
set's identifier is given as an argument, then just that data set's   
name and label will be returned.
       

\item{\begin{verbatim}pfload [file format] filename\end{verbatim}}
Loads a dataset into memory so it can be manipulated using the other
utilities.  A file format may preceed the filename in order to
indicate the file's format.  If no file type option is given, then the
extension of the filename is used to determine the default file type.
An identifier used to represent the data set will be returned upon
successful completion.

      File type options include:
\begin{itemize}
\item{\begin{verbatim}pfb\end{verbatim}} ParFlow binary format.  
Default file type for files with a `.pfb' extension.
\item{\begin{verbatim}pfsb\end{verbatim}}  ParFlow scattered binary format.
Default file type for files with a `.pfsb' extension.
\item{\begin{verbatim}sa\end{verbatim}}  ParFlow simple ASCII format.
Default file type for files with a `.sa' extension.
\item{\begin{verbatim}sb\end{verbatim}} ParFlow simple binary format.
Default file type for files with a `.sb' extension.
\item{\begin{verbatim}silo\end{verbatim}} Silo binary format.
Default file type for files with a `.silo' extension.
\item{\begin{verbatim}rsa\end{verbatim}} ParFlow real scattered ASCII format.
Default file type for files with a `.rsa' extension
\end{itemize}
      

\item{\begin{verbatim}pfloadsds filename dsnum\end{verbatim}}
This command is used to load Scientific Data Sets from HDF files.    
The SDS number `dsnum' will be used to find the SDS you wish to load
from the HDF file `filename'.  The data set loaded into memory will
be assigned an identifier which will be used to refer to the data set
until it is deleted.  This identifier will be returned upon
successful completion of the command.  
        

\item{\begin{verbatim}pfmdiff datasetp datasetq digits [zero]\end{verbatim}}
If `digits' is greater than or equal to zero, then this command     
computes the grid point at which the number of digits in agreement    
(significant digits) is fewest and differs by more than `digits'    
significant digits.  If `digits' is less than zero, then the point  
at which the number of digits in agreement (significant digits) is    
minimum is computed.  Finally, the maximum absolute difference is     
computed.  The above information is returned in a Tcl list
of the following form:
{mi mj mk sd} adiff
   
Given the search criteria, (mi, mj, mk) is the coordinate where the
minimum number of significant digits `sd' was found and `adiff' is
the maximum absolute difference.        


\item{\begin{verbatim}pfmovingaveragedem dem wsize maxiter \end{verbatim}}
This command fills sinks in the digital elevation model dem by a standard iterative
moving-average routine. Sinks are identified as cells with zero slope in both x- and
y-directions, or as local minima in elevation (i.e., all adjacent cells have higher 
elevations). At each iteration, a moving average is taken over a window of width
wsize around each remaining sink; sinks are thus filled by averaging over neighboring
cells. The procedure continues iteratively until all sinks are filled or the number 
of iterations reaches maxiter. For most applications, sinks should be filled prior
to computing slopes (i.e., prior to executing pfslopex and pfslopey). 

        
\item{\begin{verbatim}pfnewdata {nx ny nz} {x y z} {dx dy dz} label\end{verbatim}}
This command creates a new data set whose dimension is described by
the lists {nx ny nz}, {x y z}, and {dx dy dz}.  The first list,
describes the dimensions, the second indicates the origin, and the
third gives the length intervals between each coordinate along each
axis.  The `label' argument will be the label of the data set that
gets created.  This new data set that is created will have all of
its data points set to zero automatically.  An identifier for the new
data set will be returned upon successful completion.


\item{\begin{verbatim}pfnewgrid {nx ny nz} {x y z} {dx dy dz} label\end{verbatim}}
Create a new data set whose grid is described by passing three lists and a label as arguments.  
The first list will be the number of coordinates in the x, y, and z directions.  
The second list will describe the origin. The third contains the intervals between coordinates along each axis. 
The identifier of the data set created by this operation is returned upon successful completion.

\item{\begin{verbatim}pfnewlabel dataset newlabel\end{verbatim}}
This command changes the label of the data set `dataset' to
`newlabel'.
 

\item{\begin{verbatim}pfphead hhead\end{verbatim}}
This command computes the pressure head from the hydraulic head   
represented by the identifier `hhead'.  An identifier for the pressure
head is returned upon successful completion.

\item{\begin{verbatim}pfpitfilldem dem dpit maxiter \end{verbatim}}
This command fills sinks in the digital elevation model dem by a standard iterative 
pit-filling routine. Sinks are identified as cells with zero slope in both x- and 
y-directions, or as local minima in elevation (i.e., all adjacent neighbors have 
higher elevations). At each iteration, the value dpit is added to all remaining 
sinks. The procedure continues iteratively until all sinks are filled or the number
of iterations reaches maxiter. For most applications, sinks should be filled prior
to computing slopes (i.e., prior to executing pfslopex and pfslopey).

        
\item{\begin{verbatim}pfprintdata dataset\end{verbatim}}
This command executes `pfgetgrid' and `pfgetelt' in order to display
all the elements in the data set represented by the identifier
`dataset'.
        
        
\item{\begin{verbatim}pfprintdiff datasetp datasetq digits [zero]\end{verbatim}}
This command executes `pfdiffelt' and `pfmdiff' to print differences
to standard output.  The differences are printed one per line along
with the coordinates where they occur.  The last two lines displayed  
will show the point at which there is a minimum number of significant 
digits in the difference as well as the maximum absolute difference.
        
  
\item{\begin{verbatim}pfprintdomain domain\end{verbatim}} This command
 creates a set of TCL commands that setup a domain as specified by the
 provided domain input which can be then be written to a file for
 inclusion in a Parflow input script.  Note that this kind of domain
 is only supported by the SAMRAI version of Parflow.

\item{\begin{verbatim}pfprintelt i j k dataset\end{verbatim}}
This command prints a single element from the provided dataset given an i, j, k location.  
        
\item{\begin{verbatim}pfprintgrid dataset\end{verbatim}}
This command executes pfgetgrid and formats its output before printing
it on the screen.  The triples (nx, ny, nz), (x, y, z), and
(dx, dy, dz) are all printed on seperate lines along with labels
describing each.
        
        
\item{\begin{verbatim}pfprintlist [dataset]\end{verbatim}}
This command executes pflistdata and formats the output of that
command.  The formatted output is then printed on the screen.  The
output consists of a list of data sets and their labels one per line
if no argument was given or just one data set if an identifier was
given.
        
        
\item{\begin{verbatim}pfprintmdiff datasetp datasetq digits [zero]\end{verbatim}}
This command executes `pfmdiff' and formats that command's output
before displaying it on the screen.  Given the search criteria, a line
displaying the point at which the difference has the least number of
significant digits will be displayed.  Another line displaying the
maximum absolute difference will also be displayed.
 
        
\item{\begin{verbatim}printstats dataset\end{verbatim}}
This command executes `pfstats' and formats that command's output
before printing it on the screen.  Each of the values mentioned in the
description of `pfstats' will be displayed along with a label.


\item{\begin{verbatim}pfreload dataset\end{verbatim}}
This argument reloads a dataset. Only one arguments is required, the name of the dataset to reload.

\item{\begin{verbatim}pfreloadall\end{verbatim}}
This command reloads all of the current datasets.

\item{\begin{verbatim}pfsattrans mask perm\end{verbatim}}
Compute saturated transmissivity for all [i,j] as the sum of the 
permeability[i,j,k]*dz within a column [i,j]. Currently this routine
uses dz from the input permeability so the dz in permeability must be correct.
Also, it is assumed that dz is constant, so this command is not compatible with variable dz. 


\item{\begin{verbatim}pfsave dataset -filetype filename\end{verbatim}}
This command is used to save the data set given by the identifier
`dataset' to a file `filename' of type `filetype' in one of the
ParFlow formats below.

File type options include:
\begin{itemize}
\item{pfb}  ParFlow binary format.
\item{sa}  ParFlow simple ASCII format.
\item{sb}  ParFlow simple binary format.
\item{silo} Silo binary format.
\item{vis}  Vizamrai binary format.
\end{itemize}

\item{\begin{verbatim}pfsavediff datasetp datasetq digits [zero] -file filename
\end{verbatim}}
This command saves to a file the differences between the values
of the data sets represented by `datasetp' and `datasetq' to file
`filename'.  The data points whose values differ in more than         
`digits' significant digits and whose differences are greater than  
`zero' will be saved.  Also, given the above criteria, the
minimum number of digits in agreement (significant digits) will be    
saved.

If `digits' is less than zero, then only the minimum number of
significant digits and the coordinate where the minimum was
computed will be saved.

In each of the above cases, the maximum absolute difference given
the criteria will also be saved.


\item{\begin{verbatim}pfsavesds dataset -filetype filename\end{verbatim}}
This command is used to save the data set represented by the
identifier `dataset' to the file `filename' in the format given by    
`filetype'.  

The possible HDF formats are:
\begin{itemize}
\item{-float32}
\item{-float64}
\item{-int8}
\item{-uint8}
\item{-int16}
\item{-uint16}
\item{-int32}
\item{-uint32}
\end{itemize}


\item{\begin{verbatim}pfsegmentD8 dem\end{verbatim}}
This command computes the distance between the cell centers of every parent cell [i,j]
and its child cell. Child cells are determined using the eight-point pour method (commonly 
referred to as the D8 method) based on the digital elevation model dem. If [i,j] is a 
local minima the segment length is set to zero.  

\item{\begin{verbatim}pfsetgrid {nx ny nz} {x0 y0 z0} {dx dy dz} dataset\end{verbatim}}
This command replaces the grid information of dataset with the values provided. 

\item{\begin{verbatim}pfslopeD8 dem\end{verbatim}}
This command computes slopes according to the eight-point pour method (commonly
referred to as the D8 method) based on the digital elevation model dem. Slopes 
are computed as the maximum downward gradient between a given cell and it's lowest 
neighbor (adjacent or diagonal). Local minima are set to zero; where local minima 
occur on the edge of the domain, the 1st order upwind slope is used (i.e., the cell 
is assumed to drain out of the domain). Note that dem must be a ParFlow dataset and
must have the correct grid information -- dx and dy both used in slope calculations.
If gridded elevation values are read in from a text file (e.g., using pfload's simple 
ascii format), grid information must be specified using the pfsetgrid command. It should be noted that ParFlow uses slopex and slopey (NOT D8 slopes!) in runoff calculations.


\item{\begin{verbatim}pfslopex dem\end{verbatim}}
This command computes slopes in the x-direction using 1st order upwind
finite differences based on the digital elevation model dem. Slopes at local 
maxima (in x-direction) are calculated as the maximum downward gradient to 
an adjacent neighbor. Slopes at local minima (in x-direction) do not drain in 
the x-direction and are therefore set to zero. Note that dem must be a 
ParFlow dataset and must have the correct grid information -- dx in particular
is used in slope calculations. If gridded elevation values are read from a text 
file (e.g., using pfload's simple ascii format), grid inforamtion must be 
specified using the pfsetgrid command. 

\item{\begin{verbatim}pfslopexD4 dem\end{verbatim}}
This command computes the slope in the x-direction for all [i,j] using a 
four point (D4) method. The slope is set to the maximum downward slope to the 
lowest adjacent neighbor. If [i,j] is a local minima the slope is set to zero (i.e. no drainage). 


\item{\begin{verbatim}pfslopey dem\end{verbatim}}
This command computes slopes in the y-direction using 1st order upwind 
finite differences based on the digital elevation model dem. Slopes at local 
maxima (in y-direction) are calculated as the maximum downward gradient to 
an adjacent neighbor. Slopes at local minima (in y-direction) do not drain in
the y-direction and are therefore set to zero. Note that dem must be a 
ParFlow dataset and must have the correct grid information - dy in particular 
is used in slope calculations. If gridded elevation values are read in from a 
text file (e.g., using pfload's simple ascii format), grid information must be
specified using the pfsetgrid command. 


\item{\begin{verbatim}pfslopeyD4 dem\end{verbatim}}
This command computes the slope in the y-direction for all [i,j] using a four point (D4) method. 
The slope is set to the maximum downward slope to the lowest adjacent neighbor. If [i,j] is a local 
minima the slope is set to zero (i.e. no drainage). 

\item{\begin{verbatim}pfstats dataset\end{verbatim}}
This command prints various statistics for the data set represented by
the identifier `dataset'.  The minimum, maximum, mean, sum, variance,
and standard deviation are all computed.  The above values are
returned in a list of the following form:
{min max mean sum variance (standard deviation)}


\item{\begin{verbatim}pfsubsurfacestorage mask porosity pressure saturation specific_storage\end{verbatim}}
This command computes the sub-surface water storage (compressible and incompressible components) based on mask, porosity, saturation, storativity and pressure fields. The equations used to calculate this quantity are given in \S~\ref{Water Balance}. The identifier  
of the data set created by this operation is returned upon successful 
completion.  


\item{\begin{verbatim}pfsum dataset\end{verbatim}}
This command computes the sum over the domain of the dataset.


\item{\begin{verbatim}pfsurfacerunoff top slope_x slope_y  mannings pressure\end{verbatim}}
This command computes the surface water runoff (out of the domain) based
on a computed top, pressure field, slopes and mannings roughness values. 
This is integrated along all domain boundaries and is calculated at any location
that slopes at the edge of the domain point outward.  This data is in units of $[L^3 T^{-1}]$
and the equations used to calculate this quantity are given in \S~\ref{Water Balance}. 
The identifier  
of the data set created by this operation is returned upon successful 
completion.  
        

\item{\begin{verbatim}pfsurfacestorage top pressure\end{verbatim}}
This command computes the surface water storage (ponded water on top of the domain) based on a computed
top and pressure field. The equations used to calculate this quantity are given in \S~\ref{Water Balance}. The identifier  
of the data set created by this operation is returned upon successful 
completion.  


\item{\begin{verbatim}pftopodeficit profile m trans dem slopex slopey recharge ssat sres porosity mask\end{verbatim}}
Compute water deficit for all [i,j] based on TOPMODEL/topographic index. For more details on methods and assumptions 
refer to toposlopes.c in pftools.

\item{\begin{verbatim}pftopoindex dem sx sy\end{verbatim}}
Compute topographic index for all [i,j].  Here topographic index is defined as the total upstream area divided by the contour
length, divided by the local slope. For more details on methods and assumptions refer to toposlopes.c in pftools.


\item{\begin{verbatim}pftoporecharge riverfile nriver  trans dem sx sy\end{verbatim}}
Compute effective recharge at all [i,j] over upstream area based on topmodel assumptions and given list of river points.
Notes:  See detailed notes in toposlopes.c regarding assumptions, methods, etc. Input Notes: nriver is an integer (number
of river points) river  is an array of integers [nriver][2] (list of river indices, ordered from outlet to headwaters) is
a Databox of saturated transmissivity dem    is a Databox of elevations at each cell sx is a Databox of slopes (x-dir) -- 
lets you use processed slopes! sy is a Databox of slopes (y-dir) -- lets you use processed slopes!

\item{\begin{verbatim}pftopowt deficit porosity ssat sres mask top wtdepth\end{verbatim}}
Compute water depth from column water deficit for all [i,j] based on TOPMODEL/topographic index.

\item{\begin{verbatim}pfundist filename, pfundist runname\end{verbatim}}
The command undistributes a \parflow{} output file.  \parflow{} uses a
distributed file system where each node can write to its own file.
The pfundist command takes all of these individual files and collapses
them into a single file.

The arguments can be a runname or a filename.  If a runname is given
then all of the output files associated with that run are
undistributed.

Normally this is done after every pfrun command.


\item{\begin{verbatim}pfupstreamarea slope_x slope_y\end{verbatim}}
This command computes the upstream area contributing to surface runoff
at each cell based on the x and y slope values provided in datasets 
\file{slope_x} and \file{slope_y}, respectively. Contributing area is computed recursively
for each cell; areas are not weighted by slope direction. Areas are returned
as the number of upstream (contributing) cells; to compute actual area, simply
multiply by the cell area (dx*dy). 


\item{\begin{verbatim}pfvmag datasetx datasety datasetz\end{verbatim}}
This command computes the velocity magnitude when given three velocity
components.  The three parameters are identifiers which represent
the x, y, and z components respectively.  The identifier of the data
set created by this operation is returned upon successful completion.


\item{\begin{verbatim}pfvvel conductivity phead\end{verbatim}}
This command computes the Darcy velocity in cells for the conductivity
data set represented by the identifier `conductivity' and the pressure
head data set represented by the identifier `phead'.  The identifier  
of the data set created by this operation is returned upon successful 
completion.  

\item{\begin{verbatim}pfwatertabledepth top saturation \end{verbatim}}
 This command computes the water table depth (distance from top to
 first cell with saturation = 1).  The identifier of the data set
 created by this operation is returned upon successful completion.

        
\item{\begin{verbatim}pfwritedb runname\end{verbatim}}
This command writes the settings of parflow run to a pfidb database that
can be used to run the model at a later time. In general this command is used in lieu of the pfrun command. 

\end{description}        

\subsection{Common examples using \parflow{} TCL commands (PFTCL) }
\label{common_pftcl}
This section contains some brief examples of how to use the pftools commands (along with standard \emph{TCL} commands) to postprocess data.

\begin{enumerate}
\item Load a file as one format and write as another format
\item Use the mask to calculate the top of the domain, save the top of the domain as a file, apply it to the pressure output and write out as a new file.
\item Build a SAMRAI compatible domain decomposition based off of a mask file
\item Distributing input files before running.
\item Calculate slopes from an elevation file
\item Load pressure-head output from a file, convert to head-potential and write out as a new file.
\item Calculate and output the subsurface storage in the domain at a point in time.
\item Calculate and output the surface storage in the domain at a point in time.
\item Calculate and output the runoff out of the domain over a timestep.
\item Calculate overland flow at a point using Mannings equation

\end{enumerate}

\begin{enumerate}

\item Load a file as one format and write as another format.
\begin{display}\begin{verbatim}
set press [pfload harvey_flow.out.press.pfb]
pfsave $press -sa harvey_flow.out.sa

#####################################################################
# Also note that PFTCL automatically assigns 
#identifiers to each data set it stores. In this 
# example we load the pressure file and assign 
#it the identifier ¿press¿. However if you  
#read in a file called foo.pfb into a TCL shell 
#with assigning your own identifier, you get 
#the following:

#parflow> pfload foo.pfb
#dataset0

# In this example, the first line is typed in by the
#user and the second line is printed out 
#by PFTCL. It indicates that the data read 
#from file foo.pfb is associated with the 
#identifier dataset0.

\end{verbatim}\end{display}


\item Load pressure-head output from a file, convert to head-potential and write out as a new file.

\begin{display}\begin{verbatim}

set press [pfload harvey_flow.out.press.pfb]
pfsave $press -sa harvey_flow.out.sa

#####################################################################
# Also note that PFTCL automatically assigns
# identifiers to each data set it stores. In this 
# example we load the pressure file and assign 
# it the identifier ¿press¿. However if you  
# read in a file called foo.pfb into a TCL shell 
# with assigning your own idnetifier, you get 
# the following:

#parflow> pfload foo.pfb
#dataset0

# In this example, the first line is typed in by the user and the 
# second line is printed out 
# by PFTCL. It indicates that the data read from file foo.pfb is 
# associated with the 
# identifier dataset0.

\end{verbatim}\end{display}



\item Build a SAMARI compatible domain decomposition based off of a mask file
\begin{display}\begin{verbatim}
# Processor Topology
set P [lindex $argv 0]
set Q [lindex $argv 1]
set R [lindex $argv 2]
pfset Process.Topology.P $P
pfset Process.Topology.Q $Q
pfset Process.Topology.R $R

# Computational Grid
pfset ComputationalGrid.Lower.X -10.0
pfset ComputationalGrid.Lower.Y 10.0
pfset ComputationalGrid.Lower.Z 1.0

pfset ComputationalGrid.DX 8.8888888888888893
pfset ComputationalGrid.DY 10.666666666666666
pfset ComputationalGrid.DZ 1.0

pfset ComputationalGrid.NX 10
pfset ComputationalGrid.NY 10
pfset ComputationalGrid.NZ 8

# Calculate top and bottom and build domain
set mask [pfload samrai.out.mask.pfb]
set top [pfcomputetop $mask]
set bottom [pfcomputebottom $mask]

set domain [pfcomputedomain $top $bottom]
set out [pfprintdomain $domain]
set grid\_file [open samrai_grid.tcl w]

puts $grid_file $out
close $grid_file

#---------------------------------------------------------
# The resulting TCL file samrai_grid.tcl may be read into
# a Parflow input file using ¿¿source samrai_grid.tcl¿¿.
#---------------------------------------------------------

\end{verbatim}\end{display}
\item Distributing input files before running
\begin{display}\begin{verbatim}
#--------------------------------------------------------
# A common problem for new ParFlow users is to 
# distribute slope files using 
# the 3-D computational grid that is
# set at the begging of a run script. 
# This results in errors because slope 
# files are 2-D. 
# To avoid this problem the computational 
# grid should be reset before and after
# distributing slope files. As follows:
#---------------------------------------------------------

#First set NZ to 1 and distribute the 2D slope files
pfset ComputationalGrid.NX                40 
pfset ComputationalGrid.NY                40 
pfset ComputationalGrid.NZ                1
pfdist slopex.pfb
pfdist slopey.pfb

#Reset NZ to the correct value and distribute any 3D inputs
pfset ComputationalGrid.NX                40 
pfset ComputationalGrid.NY                40 
pfset ComputationalGrid.NZ                50 
pfdist IndicatorFile.pfb

\end{verbatim}\end{display}

\item Calculate slopes from an elevation file
\begin{display}\begin{verbatim}
#Read in DEM
set dem [pfload -sa dem.txt]
pfsetgrid {209 268 1} {0.0 0.0 0.0} {100 100 1.0} $dem

# Fill flat areas (if any)
set flatfill [pffillflats $dem]

# Fill pits (if any)
set  pitfill [pfpitfilldem $flatfill 0.01 10000]

# Calculate Slopes
set  slope_x [pfslopex $pitfill]
set  slope_y [pfslopey $pitfill]

# Write to output...
pfsave $flatfill -silo klam.flatfill.silo
pfsave $pitfill  -silo klam.pitfill.silo
pfsave $slope_x  -pfb  klam.slope_x.pfb
pfsave $slope_y  -pfb  klam.slope_y.pfb
\end{verbatim}\end{display}

\item Calculate and output the \emph{subsurface storage} in the domain at a point in time.
\begin{display}\begin{verbatim}
set saturation [pfload runname.out.satur.00001.silo]
set pressure [pfload runname.out.press.00001.silo]
set specific_storage [pfload runname.out.specific_storage.silo]
set porosity [pfload runname.out.porosity.silo]
set mask [pfload runname.out.mask.silo]

set subsurface_storage [pfsubsurfacestorage $mask $porosity \
$pressure $saturation $specific_storage]
set total_subsurface_storage [pfsum $subsurface_storage]
puts [format "Subsurface storage\t\t\t\t : %.16e" $total_subsurface_storage]
\end{verbatim}\end{display}

\item Calculate and output the \emph{surface storage} in the domain at a point in time.
\begin{display}\begin{verbatim}
set pressure [pfload runname.out.press.00001.silo]
set mask [pfload runname.out.mask.silo]
set top [pfcomputetop $mask]
set surface_storage [pfsurfacestorage $top $pressure]
set total_surface_storage [pfsum $surface_storage]
puts [format "Surface storage\t\t\t\t : %.16e" $total_surface_storage]
\end{verbatim}\end{display}

\item Calculate and output the runoff out of the \emph{entire domain} over a timestep.
\begin{display}\begin{verbatim}
set pressure [pfload runname.out.press.00001.silo]
set slope_x [pfload runname.out.slope_x.silo]
set slope_y [pfload runname.out.slope_y.silo]
set mannings [pfload runname.out.mannings.silo]
set mask [pfload runname.out.mask.silo]
set top [pfcomputetop $mask]

set surface_runoff [pfsurfacerunoff $top $slope_x $slope_y $mannings $pressure]
set total_surface_runoff [expr [pfsum $surface_runoff] * [pfget TimeStep.Value]]
puts [format "Surface runoff from pftools\t\t\t : %.16e" $total_surface_runoff]
\end{verbatim}\end{display}

\item Calculate overland flow at a point using \emph{Manning's} equation
\begin{display}\begin{verbatim}
#Set the location
set Xloc 2
set Yloc 2
set Zloc 50  #This should be a z location on the surface of your domain

#Set the grid dimension and Mannings roughness coefficient
set dx  1000.0
set n   0.000005

#Get the slope at the point
set slopex   [pfload runname.out.slope_x.pfb]
set slopey   [pfload runname.out.slope_y.pfb]
set sx1 [pfgetelt $slopex $Xloc $Yloc 0]
set sy1 [pfgetelt $slopey $Xloc $Yloc 0]
set S [expr ($sx**2+$sy**2)**0.5]

#Get the pressure at the point
set press [pfload runname.out.press.00001.pfb]
set P [pfgetelt $press $Xloc $Yloc $Zloc]

#If the pressure is less than zero set to zero
if {$P < 0} { set P 0 }
set QT [expr ($dx/$n)*($S**0.5)*($P**(5./3.))]
puts $QT
\end{verbatim}\end{display}

\end{enumerate}

%=============================================================================
%=============================================================================

\section{Directory of Test Cases}
\label{Test Directory}

\parflow{} comes with a directory containing a few simple input files for use
as templates in making new files and for use in testing the code.  These files sit in the \file{/test} directory described earlier. This section gives a brief description of the problems in this directory.

\begin{description}

\item{\file{crater2D.tcl} An example of a two-dimensional, variably-saturated crater infiltration prblem with time-varying boundary conditions.  It uses the solid file \file{crater2D.pfsol.}}

\item{\file{default_richards.tcl} The default variably-saturated RichardsÕ Equation simulation test script.}

\item{\file{default_single.tcl} The default parflow, single-processor, fully-saturated test script.}

\item{\file{forsyth2.tcl} An example two-dimensional, variably-saturated infiltration problem with layers of different hydraulic properties. It runs problem 2 in \cite{FWP95} and uses the solid file \file{fors2_hf.pfsol}.}

\item{\file{harvey.flow.tcl} An example from \cite{MWH07} for the Cape Cod bacterial injection site.  This example is a three-dimensional, fully-saturated flow problem with spatially heterogeneous media (using a correlated, random field approach).  It also provides examples of how tcl/tk scripts may be used in conjunction with ParFlow to loop iteratively or to run other scripts or programs.  It uses the input text file \file{stats4.txt}. This input script is fully detailed in \S~\ref{Tutorial}}

\item{\file{default_overland.tcl} An overland flow boundary condition test and example script based loosely on the V-catchment problem in \cite{KM06}.  There are options provided to expand this problem into other overland flow-type, transient boundary-type problems included in the file as well.}

\item{\file{/clm/clm.tcl} An example of how to use \parflow{} coupled to {\file{clm}}.  This directory also includes {\file{clm}}-specific input. Note: this problem will only run if {\file{--with-clm}} flag is used during the configure and build process.}

\item{\file{water_balance_x.tcl} and {\file{water_balance_y.tcl}}. An overland flow example script that uses the water-balance routines integrated into {\file{pftools}}.  These two problems are based on simple overland flow conditions with slopes primarily in the x or y-directions.  Note: this problem only will run if the Silo file capability is used, that is a {\file{--with-silo=PATH}} flag is used during the configure and build process.}

\item{\file{pfmg.tcl} and \file{pfmg_octree.tcl}. Tests of the external \emph{Hypre} preconditioner options.  Note: this problem only will run if the \emph{Hypre} capability is used, that is a {\file{--with-hypre=PATH}} flag is used during the configure and build process.}

\item{\file{pfmg.tcl} and \file{pfmg_octree.tcl}. Tests of the external \emph{Hypre} preconditioner options.  Note: this problem only will run if the \emph{Hypre} capability is used, that is a {\file{--with-hypre=PATH}} flag is used during the configure and build process.}

\item{\file{test_x.tcl} A test problem for the Richards' solver that compares output to an analytical solution.}

\end{description}

%=============================================================================
%=============================================================================

\section{Annotated Input Script}
\label{Tutorial}

This tutorial matches the \file{harvey_flow.tcl} file found in the \file{/test} directory.  This example is directly from \cite{MWH07}.  
This example demonstrates how to set up and run a fully saturated flow problem with heterogeneous hydraulic conductivity using 
the turning bands approach \cite{TAG89}. Given statistical parameters describing the geology of your site, 
this script can be easily modified to make as many realizations 
of the subsurface as you like, each different and yet having the same statistical parameters, useful for a Monte Carlo simulation.  This example
is the basis for several fully-saturated \parflow{} applications \cite{Siirila12a,Siirila12b,Siirila12c,Atchley13a,Atchley13b,Cui14m}.

To run \parflow{}, you use a script written in Tcl/TK.  This script has a lot of flexibility, as it is somewhere in between a program 
and a user interface.  The tcl script gives \parflow{} the data it requires (or tells \parflow{} where to find or read in that data) 
and also tells \parflow{} to run.

As stated above, the tcl script for the Cape Cod simulation is called \file{harvey.flow.tcl}

When the script runs, it creates a new directory named \file{/flow} right in the directory where the tcl script is stored.  \parflow{} then puts all its output in \file{/flow}.  Of course, you can change the name and location of this output directory by modifying the tcl script that runs \parflow{}.

To run the simulation:
\begin{enumerate}
\item{make any modifications to the tcl input script (and give a new name, if you want to)}
\item{save the tcl script}
\item{For Linux/Unix/OSX: invoke the script from the command line using the tcl-shell, this looks like: \file{>tclsh harvey_flow.tcl}}
\item{Wait patiently for the command prompt to return (Linux/Unix/OSX) indicating that \parflow{} has finished.  Intermediate files are written as the simulation runs, however there is no other indication that \parflow{} is running.}
\end{enumerate}

To modify a tcl script, you right-click and select edit from the menu.  If you select open, you will run the script.

{\bf Note:}  The units for {\bf K} (\i{m/d}, usually) are critical to the entire construction.  These length and time units for {\bf K} set the units for all other variables (input or generated, throughout the entire simulation) in the simulation.  \parflow{} can set to solve using hydraulic conductivity by literally setting density, viscosity and gravity to one (as is done in the script below).  This means the pressure units are in length (meters), so pressure is now so-called pressure-head.

Now for the tcl script:

\begin{verbatim}
#
# Import the ParFlow TCL package
#
\end{verbatim}

These first three lines are what link \parflow{} and the tcl script, thus allowing you to use a set of commands seen later, such as \code{pfset}, etc.

\begin{verbatim}
lappend auto_path $env(PARFLOW_DIR)/bin 
package require parflow
namespace import Parflow::*

#-----------------------------------------------------------------------------
# File input version number
#-----------------------------------------------------------------------------
pfset FileVersion 4
\end{verbatim}

These next lines set the parallel process topology.  The domain is divided in \emph{x},\emph{y} and \emph{z} by \code{P}, \code{Q} and \code{R}.
The total number of processors is \code{P*Q*R}  (\emph{see} \S~\ref{Computing Topology}).

\begin{verbatim}
#----------------------------------------------------------------------------
# Process Topology
#----------------------------------------------------------------------------

pfset Process.Topology.P     1
pfset Process.Topology.Q     1
pfset Process.Topology.R     1
\end{verbatim}

Next we set up the computational grid (\emph{see} \S~\ref{Defining the Problem} and  \S~\ref{Computational Grid}).

\begin{verbatim}
#----------------------------------------------------------------------------
# Computational Grid
#----------------------------------------------------------------------------
\end{verbatim}

Locate the origin in the domain.

\begin{verbatim}
pfset ComputationalGrid.Lower.X    0.0
pfset ComputationalGrid.Lower.Y    0.0
pfset ComputationalGrid.Lower.Z    0.0
\end{verbatim}

Define the size of the domain grid block.  Length units, same as those on hydraulic conductivity.

\begin{verbatim}
pfset ComputationalGrid.DX     0.34
pfset ComputationalGrid.DY     0.34
pfset ComputationalGrid.DZ     0.038
\end{verbatim}

Define the number of grid blocks in the domain.

\begin{verbatim}
pfset ComputationalGrid.NX      50
pfset ComputationalGrid.NY      30
pfset ComputationalGrid.NZ      100
\end{verbatim}

This next piece is comparable to a pre-declaration of variables.  These will be areas in our domain geometry. 
The regions themselves will be defined later.  You must always have one that is the name of your entire domain.  
If you want subsections within your domain, you may declare these as well.  For Cape Cod, we have the entire domain,
and also the 2 (upper and lower) permeability zones in the aquifer.

\begin{verbatim}
#----------------------------------------------------------------------------
# The Names of the GeomInputs
#----------------------------------------------------------------------------
pfset GeomInput.Names "domain_input upper_aquifer_input lower_aquifer_input"
\end{verbatim}

Now you characterize your domain that you just pre-declared to be a \code{box} (\emph{see} \S~\ref{Geometries}),
and you also give it a name, \code{domain}.

\begin{verbatim}
#----------------------------------------------------------------------------
# Domain Geometry Input
#----------------------------------------------------------------------------
pfset GeomInput.domain_input.InputType       Box
pfset GeomInput.domain_input.GeomName   domain
\end{verbatim}

Here, you set the limits in space for your entire domain.  The span from \file{Lower.X} to \file{Upper.X} 
will be equal to the product of \file{ComputationalGrid.DX} times \file{ComputationalGrid.NX}.  
Same for {\em Y} and {\em Z} (i.e. the number of grid elements times size of the grid element has to
equal the size of the grid in each dimension).   The /code{Patches} key assigns names to the outside edges, 
because the domain is the limit of the problem in space.

\begin{verbatim}
#----------------------------------------------------------------------------
# Domain Geometry
#----------------------------------------------------------------------------
pfset Geom.domain.Lower.X       0.0 
pfset Geom.domain.Lower.Y       0.0
pfset Geom.domain.Lower.Z       0.0

pfset Geom.domain.Upper.X       17.0
pfset Geom.domain.Upper.Y       10.2
pfset Geom.domain.Upper.Z       3.8

pfset Geom.domain.Patches "left right front back bottom top"
\end{verbatim}

Just like domain geometry, you also set the limits in space for the individual components 
(upper and lower, as defined in the Names of GeomInputs pre-declaration).  There are no patches 
for these geometries as they are internal to the domain.

\begin{verbatim}
#----------------------------------------------------------------------------
# Upper Aquifer Geometry Input
#----------------------------------------------------------------------------
pfset GeomInput.upper_aquifer_input.InputType        Box
pfset GeomInput.upper_aquifer_input.GeomName   upper_aquifer

#----------------------------------------------------------------------------
# Upper Aquifer Geometry
#----------------------------------------------------------------------------
pfset Geom.upper_aquifer.Lower.X                        0.0 
pfset Geom.upper_aquifer.Lower.Y                        0.0
pfset Geom.upper_aquifer.Lower.Z                        1.5

pfset Geom.upper_aquifer.Upper.X                        17.0
pfset Geom.upper_aquifer.Upper.Y                        10.2
pfset Geom.upper_aquifer.Upper.Z                        1.5

#----------------------------------------------------------------------------
# Lower Aquifer Geometry Input
#----------------------------------------------------------------------------
pfset GeomInput.lower_aquifer_input.InputType       Box
pfset GeomInput.lower_aquifer_input.GeomName   lower_aquifer

#----------------------------------------------------------------------------
# Lower Aquifer Geometry
#----------------------------------------------------------------------------
pfset Geom.lower_aquifer.Lower.X      0.0 
pfset Geom.lower_aquifer.Lower.Y      0.0
pfset Geom.lower_aquifer.Lower.Z      0.0

pfset Geom.lower_aquifer.Upper.X     17.0
pfset Geom.lower_aquifer.Upper.Y     10.2
pfset Geom.lower_aquifer.Upper.Z      1.5
\end{verbatim}

Now you add permeability data to the domain sections defined above (\S~\ref{Permeability}).  
You can reassign values simply by re-stating them -- there is no need to comment out or 
delete the previous version -- the final statement is the only one that counts.

\begin{verbatim}
#----------------------------------------------------------------------------
# Perm
#----------------------------------------------------------------------------
\end{verbatim}

Name the permeability regions you will describe.

\begin{verbatim}
pfset Geom.Perm.Names "upper_aquifer lower_aquifer"
\end{verbatim}

You can set, for example homogeneous, constant permeability, or you can generate a random 
field that meets your statistical requirements.  To define a constant permeability for the entire domain:

\begin{verbatim}
#pfset Geom.domain.Perm.Type     Constant
#pfset Geom.domain.Perm.Value    4.0
\end{verbatim}

However, for Cape Cod, we did not want a constant permeability field, so we instead generated a 
random permeability field meeting our statistical parameters for each the upper and lower zones.  
Third from the bottom is the \code{Seed}.  This is a random starting point to generate the K field.  
Pick any large {\em ODD} number.  First we do something tricky with { \file Tcl/TK}. 
We use the native commands within tcl to open a text file and read in locally set variables. 
Note we use set here and not pfset.  One is a native tcl command, the other a \parflow{}-specific command.  
For this problem, we are linking the parameter estimation code, PEST to \parflow{}. 
PEST writes out the ascii file \file{stats4.txt} (also located in the \file{/test} directory) 
as the result of a calibration run.  Since we are not coupled to PEST in this example, 
we just read in the file and use the values to assign statistical properties.

\begin{verbatim}
# we open a file, in this case from PEST to set upper and lower # kg and sigma
#
set fileId [open stats4.txt r 0600]
set kgu [gets $fileId]
set varu [gets $fileId]
set kgl [gets $fileId]
set varl [gets $fileId]
close $fileId
\end{verbatim}

Now we set the heterogeneous parameters for the Upper and Lower aquifers (\emph{see} \S~\ref{Permeability}).  
Note the special section at the very end of this block where we reset the geometric mean and standard 
deviation to our values we read in from a file.  {\bf Note:} \parflow{} uses {\em Standard Deviation} not {\em Variance}.

\begin{verbatim}
pfset Geom.upper_aquifer.Perm.Type "TurnBands"
pfset Geom.upper_aquifer.Perm.LambdaX  3.60
pfset Geom.upper_aquifer.Perm.LambdaY  3.60
pfset Geom.upper_aquifer.Perm.LambdaZ  0.19
pfset Geom.upper_aquifer.Perm.GeomMean  112.00

pfset Geom.upper_aquifer.Perm.Sigma   1.0
pfset Geom.upper_aquifer.Perm.Sigma   0.48989794
pfset Geom.upper_aquifer.Perm.NumLines 150
pfset Geom.upper_aquifer.Perm.RZeta  5.0
pfset Geom.upper_aquifer.Perm.KMax  100.0
pfset Geom.upper_aquifer.Perm.DelK  0.2
pfset Geom.upper_aquifer.Perm.Seed  33333
pfset Geom.upper_aquifer.Perm.LogNormal Log
pfset Geom.upper_aquifer.Perm.StratType Bottom
pfset Geom.lower_aquifer.Perm.Type "TurnBands"
pfset Geom.lower_aquifer.Perm.LambdaX  3.60
pfset Geom.lower_aquifer.Perm.LambdaY  3.60
pfset Geom.lower_aquifer.Perm.LambdaZ  0.19

pfset Geom.lower_aquifer.Perm.GeomMean  77.0
pfset Geom.lower_aquifer.Perm.Sigma   1.0
pfset Geom.lower_aquifer.Perm.Sigma   0.48989794
pfset Geom.lower_aquifer.Perm.NumLines 150
pfset Geom.lower_aquifer.Perm.RZeta  5.0
pfset Geom.lower_aquifer.Perm.KMax  100.0
pfset Geom.lower_aquifer.Perm.DelK  0.2
pfset Geom.lower_aquifer.Perm.Seed  33333
pfset Geom.lower_aquifer.Perm.LogNormal Log
pfset Geom.lower_aquifer.Perm.StratType Bottom

#pfset lower aqu and upper aq stats to pest/read in values

pfset Geom.upper_aquifer.Perm.GeomMean  $kgu
pfset Geom.upper_aquifer.Perm.Sigma  $varu

pfset Geom.lower_aquifer.Perm.GeomMean  $kgl
pfset Geom.lower_aquifer.Perm.Sigma  $varl
\end{verbatim}

The following section allows you to specify the permeability tensor.  
In the case below, permeability is symmetric in all directions (x, y, and z) and therefore each is set to 1.0.

\begin{verbatim}
pfset Perm.TensorType               TensorByGeom

pfset Geom.Perm.TensorByGeom.Names  "domain"

pfset Geom.domain.Perm.TensorValX  1.0
pfset Geom.domain.Perm.TensorValY  1.0
pfset Geom.domain.Perm.TensorValZ  1.0
\end{verbatim}

Next we set the specific storage, though this is not used in the IMPES/steady-state calculation.

\begin{verbatim}
#----------------------------------------------------------------------------
# Specific Storage
#----------------------------------------------------------------------------
# specific storage does not figure into the impes (fully sat) 
# case but we still need a key for it

pfset SpecificStorage.Type            Constant
pfset SpecificStorage.GeomNames       ""
pfset Geom.domain.SpecificStorage.Value 1.0e-4
\end{verbatim}

\parflow{} has the capability to deal with a multiphase system, but we only have one (water) at Cape Cod. 
As we stated earlier, we set density and viscosity artificially (and later gravity) both to 1.0.  
Again, this is merely a trick to solve for hydraulic conductivity and pressure head.  
If you were to set density and viscosity to their true values, the code would calculate {\bf k} (permeability). 
By using the \emph{normalized} values instead, you effectively embed the conversion of {\bf k} to {\bf K} (hydraulic conductivity). 
So this way, we get hydraulic conductivity, which is what we want for this problem.

\begin{verbatim}
#----------------------------------------------------------------------------
# Phases
#----------------------------------------------------------------------------

pfset Phase.Names "water"

pfset Phase.water.Density.Type	Constant
pfset Phase.water.Density.Value	1.0

pfset Phase.water.Viscosity.Type	Constant
pfset Phase.water.Viscosity.Value	1.0
\end{verbatim}

We will not use the \parflow{} grid based transport scheme.  We will then leave 
contaminants blank because we will use a different code for to model (virus, tracer) contamination.

\begin{verbatim}
#----------------------------------------------------------------------------
# Contaminants
#----------------------------------------------------------------------------
pfset Contaminants.Names			""
\end{verbatim}

As with density and viscosity, gravity is normalized here.  If we used the true value
(in the \emph{[L]} and \emph{[T]} units of hydraulic conductivity) the code would be calculating permeability.  
Instead, we normalize so that the code calculates hydraulic conductivity.

\begin{verbatim}
#----------------------------------------------------------------------------
# Gravity
#----------------------------------------------------------------------------

pfset Gravity				1.0

#----------------------------------------------------------------------------
# Setup timing info
#----------------------------------------------------------------------------
\end{verbatim}

This basic time unit of 1.0 is used for transient boundary and well conditions. 
We are not using those features in this example.

\begin{verbatim} 
pfset TimingInfo.BaseUnit		1.0
\end{verbatim}

Cape Cod is a steady state problem, so these timing features are again unused, but need to be included.

\begin{verbatim}
pfset TimingInfo.StartCount   -1
pfset TimingInfo.StartTime     0.0
pfset TimingInfo.StopTime     0.0
\end{verbatim}

Set the \code{dump interval} to -1 to report info at the end of every calculation, 
which in this case is only when steady state has been reached.

\begin{verbatim}
pfset TimingInfo.DumpInterval	       -1
\end{verbatim}

Next, we assign the porosity (\emph{see} \S~\ref{Porosity}).  For the Cape Cod, the porosity is 0.39.  

\begin{verbatim}
#----------------------------------------------------------------------------
# Porosity
#----------------------------------------------------------------------------

pfset Geom.Porosity.GeomNames          domain

pfset Geom.domain.Porosity.Type    Constant
pfset Geom.domain.Porosity.Value   0.390
\end{verbatim}

Having defined the geometry of our problem before and named it \code{domain}, we are
now ready to report/upload that problem, which we do here.

\begin{verbatim}
#----------------------------------------------------------------------------
# Domain
#----------------------------------------------------------------------------
pfset Domain.GeomName domain
\end{verbatim}

Mobility between phases is set to 1.0 because we only have one phase (water).

\begin{verbatim}
#----------------------------------------------------------------------------
# Mobility
#----------------------------------------------------------------------------
pfset Phase.water.Mobility.Type        Constant
pfset Phase.water.Mobility.Value       1.0
\end{verbatim}

Again, \parflow{} has more capabilities than we are using here in the Cape Cod example. 
For this example, we handle monitoring wells in a separate code as we assume they
do not remove a significant amount of water from the domain.  Note that since 
there are no well names listed here, \parflow{} assumes we have no wells. 
If we had pumping wells, we would have to include them here, because they 
would affect the head distribution throughout our domain.  See below for an example of how to 
include pumping wells in this script.

\begin{verbatim}
#----------------------------------------------------------------------------
# Wells
#----------------------------------------------------------------------------
pfset Wells.Names ""
\end{verbatim}

You can give certain periods of time names if you want to (ie. Pre-injection, post-injection, etc).  
Here, however we do not have multiple time intervals and are simulating in steady state, so time cycle 
keys are simple.  We have only one time cycle and it's constant for the duration of the simulation. 
We accomplish this by giving it a repeat value of -1, which repeats indefinitely.  The length of 
the cycle is the length specified below (an integer) multiplied by the base unit value we specified earlier.

\begin{verbatim}
#----------------------------------------------------------------------------
# Time Cycles
#----------------------------------------------------------------------------
pfset Cycle.Names constant
pfset Cycle.constant.Names		"alltime"
pfset Cycle.constant.alltime.Length	 1
pfset Cycle.constant.Repeat		-1
\end{verbatim}

Now, we assign Boundary Conditions for each face (each of the Patches in the domain defined before).  
Recall the previously stated Patches and associate them with the boundary conditions that follow.

\begin{verbatim}
pfset BCPressure.PatchNames "left right front back bottom top"
\end{verbatim}

These are Dirichelet BCs (i.e. constant head over cell so the pressure head 
is set to hydrostatic-- \emph{see} \S~\ref{Boundary Conditions: Pressure}).  
There is no time dependence, so use the \code{constant} time cycle we defined previously.  
\code{RefGeom} links this to the established domain geometry and tells \parflow{} 
what to use for a datum when calculating hydrostatic head conditions.

\begin{verbatim}
pfset Patch.left.BCPressure.Type          DirEquilRefPatch
pfset Patch.left.BCPressure.Cycle        "constant"
pfset Patch.left.BCPressure.RefGeom domain
\end{verbatim}

Reference the current (left) patch to the bottom to define the line of intersection between the two.

\begin{verbatim}
pfset Patch.left.BCPressure.RefPatch  bottom
\end{verbatim}

Set the head permanently to 10.0m.  Pressure-head will of course vary top to bottom because of hydrostatics, 
but head potential will be constant.

\begin{verbatim}
pfset Patch.left.BCPressure.alltime.Value  10.0
\end{verbatim}

Repeat the declarations for the rest of the faces of the domain.  The left to right (\emph{X}) 
dimension is aligned with the hydraulic gradient.  The difference between the values assigned to 
right and left divided by the length of the domain corresponds to the correct hydraulic gradient.

\begin{verbatim}
pfset Patch.right.BCPressure.Type               DirEquilRefPatch
pfset Patch.right.BCPressure.Cycle              "constant"
pfset Patch.right.BCPressure.RefGeom       domain
pfset Patch.right.BCPressure.RefPatch       bottom
pfset Patch.right.BCPressure.alltime.Value 9.97501

pfset Patch.front.BCPressure.Type                FluxConst
pfset Patch.front.BCPressure.Cycle              "constant"
pfset Patch.front.BCPressure.alltime.Value 0.0

pfset Patch.back.BCPressure.Type               FluxConst
pfset Patch.back.BCPressure.Cycle              "constant"
pfset Patch.back.BCPressure.alltime.Value 0.0

pfset Patch.bottom.BCPressure.Type               FluxConst
pfset Patch.bottom.BCPressure.Cycle              "constant"
pfset Patch.bottom.BCPressure.alltime.Value 0.0

pfset Patch.top.BCPressure.Type			FluxConst
pfset Patch.top.BCPressure.Cycle			"constant"
pfset Patch.top.BCPressure.alltime.Value		0.0
\end{verbatim}

Next we define topographic slopes and Mannings \emph{n} values. 
These are not used, since we do not solve for overland flow.  
However, the keys still need to appear in the input script.

\begin{verbatim}
#---------------------------------------------------------
# Topo slopes in x-direction
#---------------------------------------------------------
# topo slopes do not figure into the impes (fully sat) case but we still
# need keys for them

pfset TopoSlopesX.Type "Constant"
pfset TopoSlopesX.GeomNames ""

pfset TopoSlopesX.Geom.domain.Value 0.0

#---------------------------------------------------------
# Topo slopes in y-direction
#---------------------------------------------------------

pfset TopoSlopesY.Type "Constant"
pfset TopoSlopesY.GeomNames ""

pfset TopoSlopesY.Geom.domain.Value 0.0

#---------------------------------------------------------
# Mannings coefficient 
#---------------------------------------------------------
# mannings roughnesses do not figure into the impes (fully sat) case but we still
# need a key for them

pfset Mannings.Type "Constant"
pfset Mannings.GeomNames ""
pfset Mannings.Geom.domain.Value 0.
\end{verbatim}

Phase sources allows you to add sources other than wells and boundaries, but 
we do not have any so this key is constant, 0.0 over entire domain.

\begin{verbatim}
#----------------------------------------------------------------------------
# Phase sources:
#----------------------------------------------------------------------------

pfset PhaseSources.water.Type                         Constant
pfset PhaseSources.water.GeomNames                    domain
pfset PhaseSources.water.Geom.domain.Value        0.0
\end{verbatim}

Next we define solver parameters for {\bf IMPES}.  Since this is the default solver, we do not need a solver key.

\begin{verbatim}
#---------------------------------------------------------
#  Solver Impes  
#---------------------------------------------------------
\end{verbatim}

We allow up to 50 iterations of the linear solver before it quits or converges.

\begin{verbatim}
pfset Solver.MaxIter 50
\end{verbatim}

The solution must be accurate to this level 

\begin{verbatim}
pfset Solver.AbsTol  1E-10
\end{verbatim}

We drop significant digits beyond E-15

\begin{verbatim}
pfset Solver.Drop   1E-15

#--------------------------------------------------------
# Run and Unload the ParFlow output files
#---------------------------------------------------------
\end{verbatim}

Here you set the number of realizations again using a local tcl variable.  
We have set only one run but by setting the \file{n_runs} variable to something 
else we can run more than one realization of hydraulic conductivity. 

\begin{verbatim}
# this script is setup to run 100 realizations, for testing we just run one
###set n_runs 100
set n_runs 1
\end{verbatim}

Here is where you tell \parflow{} where to put the output.  
In this case, it is a directory called flow.  
Then you cd (change directory) into that new directory.  
If you wanted to put an entire path rather than just a name, 
you would have more control over where your output file goes.  
For example, you would put \file{file mkdir "/cape_cod/revised_statistics/flow"} 
and then change into that directory. 

\begin{verbatim}
file mkdir "flow"
cd "flow"
\end{verbatim}

Now we loop through the realizations, again using tcl.  \file{k} is the
integer counter that is incremented for each realization.  When you use a variable
(rather than define it), you precede it with\verb+$+.  The hanging character \verb+{+ 
opens the do loop for \file{k}.

\begin{verbatim}
#
#  Loop through runs
#
for {set k 1} {$k <= $n_runs} {incr k 1} {
\end{verbatim}

The following expressions sets the variable \code{seed} equal to the expression in brackets,
which increments with each turn of the do loop and each seed will produce a different random field of {\bf K}.  
You set upper and lower aquifer, because in the Cape Cod site, these are the two subsets of the domain. 
Note the seed starts at a different point to allow for different random field generation for the upper 
and lower zones.

\begin{verbatim}
#
# set the random seed to be different for every run
#
pfset Geom.upper_aquifer.Perm.Seed  [ expr 33333+2*$k ] 
pfset Geom.lower_aquifer.Perm.Seed  [ expr 31313+2*$k ]
\end{verbatim}

The following command runs \parflow{} and gives you a suite of output files for each realization.  
The file names will begin \file{harvey_flow.1.xxxxx}, \file{harvey_flow.2.xxxx}, etc up to as many realizations as you run.  
The .xxxxx part will designate x, y, and z permeability, etc. Recall that in this case, since we normalized gravity, viscosity, 
and density, remember that we are really getting hydraulic conductivity.

\begin{verbatim}
pfrun harvey_flow.$k
\end{verbatim}

This command removes a large number of superfluous dummy files or un-distributes parallel files back into a single file. If you
compile with the \code{-- with-amps-sequential-io} option then a single \parflow{} file is written with corresponding \file{XXXX.dist} files and the 
\code{pfundist} command just removes these \file{.dist} files (though you don't really need to remove them if you don't want to).

\begin{verbatim}
pfundist harvey_flow.$k
\end{verbatim}

The following commands take advantage of PFTools (\emph{see} \S~\ref{PFTCL Commands}) and load pressure head output of the
/parflow{} model into a pressure matrix.

\begin{verbatim}
# we use pf tools to convert from pressure to head
# we could do a number of other things here like copy files to different
# format
set press [pfload harvey_flow.$k.out.press.pfb]
\end{verbatim}

The next command takes the pressures that were just loaded and converts it to head and loads them into a head matrix tcl variable.

\begin{verbatim}
set head [pfhhead $press]
\end{verbatim}

Finally, the head matrix is saved as a \parflow{} binary file (.pfb) and the k do loop is closed by the \verb+}+ character.  
Then we move up to the root directory when we are finished

\begin{verbatim}
 pfsave $head -pfb harvey_flow.$k.head.pfb
}

cd ".."
\end{verbatim}

Once you have modified the tcl input script (if necessary) and run \parflow{}, you will have as
many realizations of your subsurface as you specified.  Each of these realizations will be used 
as input for a particle or streamline calculation in the future.  We can see below, that since 
we have a tcl script as input, we can do a lot of different operations, for example, we might 
run a particle tracking transport code simulation using the results of the \parflow{} runs.  
This actually corresponds to the example presented in the \code{SLIM} user's manual.

\begin{verbatim}
# this could run other tcl scripts now an example is below
#puts stdout "running SLIM"
#source bromide_trans.sm.tcl
\end{verbatim}

We can add options to this script.  For example if we wanted to add a pumping well
%==============================
\subsection*{Adding a Pumping Well}

Let us change the input problem by adding a pumping well:
\begin{enumerate}


\item 
Add the following lines to the input file near where the existing
well information is in the input file.  You need to replace
the ``Wells.Names'' line with the one included here to get both
wells activated (this value lists the names of the wells):

\begin{display}\begin{verbatim}
pfset Wells.Names {new_well}

pfset Wells.new_well.InputType                Recirc

pfset Wells.new_well.Cycle		    constant

pfset Wells.new_well.ExtractionType	    Flux
pfset Wells.new_well.InjectionType            Flux

pfset Wells.new_well.X			    10.0 
pfset Wells.new_well.Y			    10.0
pfset Wells.new_well.ExtractionZLower	     0.5
pfset Wells.new_well.ExtractionZUpper	     0.5
pfset Wells.new_well.InjectionZLower	     0.2
pfset Wells.new_well.InjectionZUpper	     0.2

pfset Wells.new_well.ExtractionMethod	    Standard
pfset Wells.new_well.InjectionMethod          Standard

pfset Wells.new_well.alltime.Extraction.Flux.water.Value        	     0.50
pfset Wells.new_well.alltime.Injection.Flux.water.Value		     0.75

\end{verbatim}\end{display}

\end{enumerate}
For more information on defining the problem,
see \S~\ref{Defining the Problem}.

We could also visualize the results of the \parflow{} simulations, using \emph{VisIt}. 
For example, we can turn on \emph{SILO} file output which allows these files to be directly
read and visualized.  We would do this by adding the following \code{pfset} commands, I usually 
add them to the solver section:
\begin{display}\begin{verbatim}
pfset Solver.WriteSiloSubsurfData True
pfset Solver.WriteSiloPressure True
pfset Solver.WriteSiloSaturation True
\end{verbatim}\end{display}


You can then directly open \file{harvey_flow.#.out.perm_x.silo} (where \file{#} is the realization number) will be the field of your domain, showing the variation in x-permeability in 3-D space.
You can also generate representations of head or pressure (or y or z permeability) throughout your domain using \parflow{} output files. 
See the section on visualization for more details.

%============
%============
