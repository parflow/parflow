%=============================================================================
%=============================================================================

\chapter{The ParFlow System}
\label{The ParFlow System}

The \parflow{} system is still evolving, but here we discuss how to define the problem in
\S~\ref{Defining the Problem}, how to run \parflow{} in
\S~\ref{Running ParFlow}, and options for to visualizing the results in
\S~\ref{Visualizing Output}.  There is also a utility providing a set
of functions for manipulating \parflow{} data.  This utility is discussed in 
\S~\ref{Manipulating Data}.  Lastly, \S~\ref{Test Directory} discusses the
contents of a directory of test problems provided with \parflow{}.

%=============================================================================
%=============================================================================

\section{Defining the Problem}
\label{Defining the Problem}

Defining the problem may involve several steps.
One of these steps may require definition complicated geometries such as hydrostratigraphic layers.
These geometries are then converted to the
\file{.pfsol} file format (\S~\ref{ParFlow Solid Files (.pfsol)})
using the appropriate \pftools{} conversion utility
(\S~\ref{Manipulating Data}).

The ``main'' \parflow{} input file is the \file{.pftcl} file.
This input file is a TCL script with some special routines to
create a database which is used as the input for \parflow{}.
See \S~\ref{Main Input File (.pftcl)} for details on the format
of this file.
The input values into \parflow{} are defined by a key/value pair.  For
each key you provide the associated value using the \code{pfset} command
inside the input script.  To set the computational grid for the problem
you would enter:

\begin{display}\begin{verbatim}
#-----------------------------------------------------------------------------
# Computational Grid
#-----------------------------------------------------------------------------
pfset ComputationalGrid.Lower.X                -10.0
pfset ComputationalGrid.Lower.Y                 10.0
pfset ComputationalGrid.Lower.Z                  1.0
 
pfset ComputationalGrid.DX                       8.8888888888888893
pfset ComputationalGrid.DY                      10.666666666666666
pfset ComputationalGrid.DZ                       1.0
 
pfset ComputationalGrid.NX                      18
pfset ComputationalGrid.NY                      15
pfset ComputationalGrid.NZ                       8

\end{verbatim}\end{display}

The value is normally a single string, double, or integer.  In some cases,
in particular for a list of names, you need to supply a space seperated
sequence.  This can be done using either a double quote or bracies.

\begin{display}\begin{verbatim}
pfset Geom.domain.Patches "left right front back bottom top"

pfset Geom.domain.Patches {left right front back bottom top}
\end{verbatim}\end{display}

For commands longer than a single line, the TCL continuation character can be
used, 
\begin{display}\begin{verbatim}
pfset Geom.domain.Patches "very_long_name_1 very_long_name_2 very_long_name_3 \
                           very_long_name_4 very_long_name_5 very_long_name_6"
\end{verbatim}\end{display}


Since the input file is a TCL script you can use any feature of TCL to
define the problem.  This manual will make no effort to teach TCL so
refer to one of the available TCL manuals for more information
(``Practical Programming in TCL and TK'' by Brent Welch \cite{welch.95} 
is a good starting point).  
This is NOT required, you can get along fine without understanding TCL/TK.

Looking at the example programs in the \file{test} directory is one of
the best ways to understand what a \parflow{} input file looks like. See
\S~\ref{Test Directory}.  

%=============================================================================
%=============================================================================

\section{Running ParFlow}
\label{Running ParFlow}

Once the problem input is defined, you need to add a few things to 
the script to make it execute \parflow{}.  First you need to add
the TCL commands to load the \parflow{} command package.

\begin{display}\begin{verbatim}
#
# Import the ParFlow TCL package
#
lappend auto_path $env(PARFLOW_DIR)/bin 
package require parflow
namespace import Parflow::*
\end{verbatim}\end{display}

This loads the \code{pfset} and other \parflow{} commands into the
TCL shell.

Since this is a script you need to actually run \parflow{}. These are
normally the last lines of the input script.

\begin{display}\begin{verbatim}
#-----------------------------------------------------------------------------
# Run and Unload the ParFlow output files
#-----------------------------------------------------------------------------
pfrun default_single
pfundist default_single
\end{verbatim}\end{display}


The \code{pfrun} command runs \parflow{} with the database as it
exists at that point in the file.  The argument is the name to give to
the output files (which will normally be the same as the name of the
script).  Advanced users can set up multiple problems within the input
script by using different output names.  

The \code{pfundist} command takes the output files from the \parflow{}
run and undistributes them.  \parflow{} uses a virtual file system
which allows files to be distributed across the processors.  The
\code{pfundist} takes these files and collapses them into a single
file.  On some machines if you don't do the \code{pfundist} you will
see many files after the run.  Each of these contains the output from
a single node; before attempting using them you should undistribute them.

Since the input file is a TCL script run it using TCL:

\begin{display}\begin{verbatim}
tclsh runname.pftcl
\end{verbatim}\end{display}

NOTE: Make sure you are using TCL 8.0 or later.  The script will not
work with earlier releases.

For a network of workstations, you need to specify the computer
systems that are going to be used in the virtual machine (VM).  To add
a machine to the VM you should set the \code{Process.HostNames}
variable to be a space separated list of the machine names.

\begin{display}\begin{verbatim}
pfset Process.Hostnames ``bert.llnl.gov ernie.llnl.gov bigbird.llnl.gov''
\end{verbatim}\end{display}

One output file of particular interest is the \file{<run
name>.out.log} file.  This file contains information about the run
such as number of processes used, convergence history of algorithms,
timings and MFLOP rates.

\section{Restarting a Run}
\label{Restarting a Run}

Occasionally a \parflow{} run may need to be restarted because either a
system time limit has been reached and \parflow{} has been prematurely
terminated or the user specifically sets up a problem to run in segments.
In order to restart a run the user needs to know the conditions under which
\parflow{} stopped.  If \parflow{} was prematurely terminated then the
user must examine the output files from the last ``timed dump'' to see if
they are complete.  If not then those data files should be discarded and the
output files from the next to last ``timed dump'' will be used in the
restarting procedure.  As an important note, if any set of ``timed dump''
files are deleted remember to also delete corresponding lines in the well
output file or recombining the well output files from the individual segments
afterwards will be difficult.  It is not necessary to delete lines from
the log file as you will only be noting information from it.  To summarize,
make sure all the important output data files are complete, accurate and
consistent with each other.

Given a set of complete, consistent output files - to restart a run follow
this procedure :

\begin{enumerate}
   \item Note the important information for restarting :
   \begin{itemize}
      \item Write down the dump sequence number for the last collection of
           ``timed dump'' data.
      \item Examine the log file to find out what real time that ``timed dump''
            data was written out at and write it down.
   \end{itemize}
   \item Prepare input data files from output data files :
   \begin{itemize}
      \item Take all the concentration output files with the sequence number
            from above and convert them from a ParFlow Scattered Binary File
            \S~\ref{ParFlow Scattered Binary Files (.pfsb)} to a ParFlow
            Binary File \S~\ref{ParFlow Binary Files (.pfb)} (including a
            ``.dist'' file) using \pftools{} \S~\ref{Manipulating Data} and the
            {\it pfdist} utility in the input script.
   \end{itemize}
   \item Change the Main Input File \S~\ref{Main Input File (.pftcl)} :
   \begin{itemize}
      \item Edit the .pftcl file (you may want to save the old one) and
            utilize the read concentration input file option to specify
            all of the input files you created above as initial conditions
            for concentrations.
   \end{itemize}
   \item Restart the run :
   \begin{itemize}
      \item Utilizing an editor recreate all the input parameters used
            in the run except for the following two items :
            \begin{itemize}
               \item Use the dump sequence number from step 1
                     as the start\_count.
               \item Use the real time that the dump occured at from step 1
                     as the start\_time.
            \end{itemize}
   \end{itemize}
\end{enumerate}

%=============================================================================
%=============================================================================

\section{Visualizing Output}
\label{Visualizing Output}


%=============================================================================
%=============================================================================

\section{Manipulating Data}
\label{Manipulating Data}

\subsection{Introduction to the \parflow{} TCL commands (PFTCL) }

Several tools for manipulating data are provided in PFTCL command set.
In order to use them you need to load the \parflow{} package into
the TCL shell.  If you are doing simple data manipulation the
\file{xpftools} provides GUI access to most of these features.
All of these tools are accessible inside of a \parflow{} input script.
You can use them to do post and pre processing of datafiles each time
you execute a run.

\begin{display}\begin{verbatim}
#
# To Import the ParFlow TCL package
#
lappend auto_path $env(PARFLOW_DIR)/bin 
package require parflow
namespace import Parflow::*
\end{verbatim}\end{display}

Use \kbd{pfhelp} to get a list of commands.

PFTCL assigns identifiers to each data set it stores.
For example, if you read in a file called \file{foo.pfb},
you get the following:
\begin{display}\begin{verbatim}
parflow> pfload foo.pfb
dataset0
\end{verbatim}\end{display}
The first line is typed in by the user and the second line
is printed out by PFTCL.
It indicates that the data read from file \file{foo.pfb} is
associated with the identifier \code{dataset0}.

To exit use the standard TCL command \kbd{exit}.

\subsection{PFTCL Commands}
\label{PFTCL Commands}
The following gives a list of \parflow{} commands and instructions for their use:
Note that commands that perform operations on data sets will
require an identifier for each data set it takes as input.

\begin{description}

\item{\begin{verbatim}pfaxpy alpha x y\end{verbatim}}
This command computes y = alpha*x+y where alpha is a scalar and x and 
y are identifiers representing data sets.  No data set identifier is
returned upon successful completion since data set y is overwritten.

\item{\begin{verbatim}pfcvel conductivity phead\end{verbatim}}
This command computes the Darcy velocity in cells for the conductivity data set
represented by the identifier `conductivity' and the pressure head
data set represented by the identifier `phead'.  (note: This "cell"
is not the same as the grid cells; its corners are defined by the
grid vertices.)  The identifier of the data set created by this
operation is returned upon successful completion.

\item{\begin{verbatim}pfdelete dataset\end{verbatim}}
This command deletes the data set represented by the identifier `dataset'.
        
\item{\begin{verbatim}pfdiffelt datasetp datasetq i j k digits [zero]\end{verbatim}}
This command returns the difference of two corresponding coordinates
from `datasetp' and `datasetq' if the number of digits in agreement
(significant digits) differs by more than `digits' significant
digits and the difference is greater than the absolute zero given     
by `zero'.


\item{\begin{verbatim}pfdist filename \end{verbatim}}
Distribute the file onto the virtual file system.  This utility must
be used to create files which \parflow{} can use as input.  \parflow{}
uses a virtual file system which allows each node of the parallel
machine to read from the input file independentaly.  The utility does
the inverse of the pfundist command.  If you are using a \parflow{}
binary file for input you should do a pfdist just before you do the
pfrun.  This command requires that the processor topology and
computational grid be set in the input file so that it knows how to
distribute the data.

\item{\begin{verbatim}pfflux conductivity hhead\end{verbatim}}
This command computes the net Darcy flux at vertices for the
conductivity data set `conductivity' and the hydraulic head data      
set given by `hhead'.  An identifier representing the flux computed   
will be returned upon successful completion.
        
\item{\begin{verbatim}pfgetelt dataset i j k\end{verbatim}}
This command returns the value at element (i,j,k) in data set         
`dataset'.  The i, j, and k above must range from 0 to (nx - 1), 0 to 
(ny - 1), and 0 to (nz - 1) respectively.  The values nx, ny, and nz
are the number of grid points along the x, y, and z axes respectively.
The string `dataset' is an identifier representing the data set whose
element is to be retrieved.
        
\item{\begin{verbatim}pfgetgrid dataset\end{verbatim}}
This command returns a description of the grid which serves as the
domain of data set `dataset'.  The format of the description is given 
below.
\begin{itemize}
\item{\begin{verbatim}(nx, ny, nz)\end{verbatim}
The number of coordinates in each direction.}
\item{\begin{verbatim}(x, y, z)\end{verbatim}The origin of the grid.}
\item{\begin{verbatim}(dx, dy, dz)\end{verbatim}The distance between each
coordinate in each direction.}
\end{itemize}
The above information is returned in the following Tcl list format:
{nx ny nz} {x y z} {dx dy dz}
        
\item{\begin{verbatim}pfgridtype gridtype\end{verbatim}}
This command sets the grid type to either cell centered if `gridtype'
is set to `cell' or vetex centered if `gridtype' is set to `vertex'.
If no new value for `gridtype' is given, then the current value of
`gridtype' is returned.  The value of `gridtype' will be returned upon
successful completion of this command.

\item{\begin{verbatim}pfhhead phead\end{verbatim}}
This command computes the hydraulic head from the pressure head       
represented by the identifier `phead'.  An identifier for the 
hydraulic head computed is returned upon successful completion.

\item{\begin{verbatim}pflistdata dataset\end{verbatim}}
This command returns a list of pairs if no argument is given.  The
first item in each pair will be an identifier representing the data   
set and the second item will be that data set's label.  If a data     
set's identifier is given as an argument, then just that data set's   
name and label will be returned.
       
\item{\begin{verbatim}pfload [file format] filename\end{verbatim}}

Loads a dataset into memory so it can be manipulated using the other
utilities.  A file format may preceed the filename in order to
indicate the file's format.  If no file type option is given, then the
extension of the filename is used to determine the default file type.
An identifier used to represent the data set will be returned upon
successful completion.

      File type options include:
\begin{itemize}
\item{\begin{verbatim}pfb\end{verbatim}} ParFlow binary format.  
Default file type for files with a `.pfb' extension.
\item{\begin{verbatim}pfsb\end{verbatim}}  ParFlow scattered binary format.
Default file type for files with a `.pfsb' extension.
\item{\begin{verbatim}sa\end{verbatim}}  ParFlow simple ASCII format.
Default file type for files with a `.sa' extension.
\item{\begin{verbatim}sb\end{verbatim}} ParFlow simple binary format.
Default file type for files with a `.sb' extension.
\item{\begin{verbatim}rsa\end{verbatim}} ParFlow real scattered ASCII format.
Default file type for files with a `.rsa' extension
\end{itemize}
      
\item{\begin{verbatim}pfloadsds filename dsnum\end{verbatim}}
This command is used to load Scientific Data Sets from HDF files.    
The SDS number `dsnum' will be used to find the SDS you wish to load
from the HDF file `filename'.  The data set loaded into memory will
be assigned an identifier which will be used to refer to the data set
until it is deleted.  This identifier will be returned upon
successful completion of the command.  
        
\item{\begin{verbatim}pfmdiff datasetp datasetq digits [zero]\end{verbatim}}
If `digits' is greater than or equal to zero, then this command     
computes the grid point at which the number of digits in agreement    
(significant digits) is fewest and differs by more than `digits'    
significant digits.  If `digits' is less than zero, then the point  
at which the number of digits in agreement (significant digits) is    
minimum is computed.  Finally, the maximum absolute difference is     
computed.  The above information is returned in a Tcl list
of the following form:
{mi mj mk sd} adiff
   
Given the search criteria, (mi, mj, mk) is the coordinate where the
minimum number of significant digits `sd' was found and `adiff' is
the maximum absolute difference.        
        
        
\item{\begin{verbatim}pfnewdata {nx ny nz} {x y z} {dx dy dz} label\end{verbatim}}
This command creates a new data set whose dimension is described by
the lists {nx ny nz}, {x y z}, and {dx dy dz}.  The first list,
describes the dimensions, the second indicates the origin, and the
third gives the length intervals between each coordinate along each
axis.  The `label' argument will be the label of the data set that
gets created.  This new data set that is created will have all of
its data points set to zero automatically.  An identifier for the new
data set will be returned upon successful completion.


\item{\begin{verbatim}pfnewlabel dataset newlabel\end{verbatim}}
This command changes the label of the data set `dataset' to
`newlabel'.
 
\item{\begin{verbatim}pfphead hhead\end{verbatim}}
This command computes the pressure head from the hydraulic head   
represented by the identifier `hhead'.  An identifier for the pressure
head is returned upon successful completion.
        
\item{\begin{verbatim}pfsavediff datasetp datasetq digits [zero] -file filename
\end{verbatim}}
This command saves to a file the differences between the values
of the data sets represented by `datasetp' and `datasetq' to file
`filename'.  The data points whose values differ in more than         
`digits' significant digits and whose differences are greater than  
`zero' will be saved.  Also, given the above criteria, the
minimum number of digits in agreement (significant digits) will be    
saved.

If `digits' is less than zero, then only the minimum number of
significant digits and the coordinate where the minimum was
computed will be saved.

In each of the above cases, the maximum absolute difference given
the criteria will also be saved.

\item{\begin{verbatim}pfsave dataset -filetype filename\end{verbatim}}
This command is used to save the data set given by the identifier
`dataset' to a file `filename' of type `filetype' in one of the
ParFlow formats below.

File type options include:
\begin{itemize}
\item{pfb}  ParFlow binary format.
\item{sa}  ParFlow simple ASCII format.
\item{sb}  ParFlow simple binary format.
\item{vis}  Vizamrai binary format.
\end{itemize}

\item{\begin{verbatim}pfsavesds dataset -filetype filename\end{verbatim}}
This command is used to save the data set represented by the
identifier `dataset' to the file `filename' in the format given by    
`filetype'.  

The possible HDF formats are:
\begin{itemize}
\item{-float32}
\item{-float64}
\item{-int8}
\item{-uint8}
\item{-int16}
\item{-uint16}
\item{-int32}
\item{-uint32}
\end{itemize}

       
\item{\begin{verbatim}pfstats dataset\end{verbatim}}
This command prints various statistics for the data set represented by
the identifier `dataset'.  The minimum, maximum, mean, sum, variance,
and standard deviation are all computed.  The above values are
returned in a list of the following form:
{min max mean sum variance (standard deviation)}
        
        
\item{\begin{verbatim}pfvmag datasetx datasety datasetz\end{verbatim}}
This command computes the velocity magnitude when given three velocity
components.  The three parameters are identifiers which represent
the x, y, and z components respectively.  The identifier of the data
set created by this operation is returned upon successful completion.


\item{\begin{verbatim}pfvvel conductivity phead\end{verbatim}}
This command computes the Darcy velocity in cells for the conductivity
data set represented by the identifier `conductivity' and the pressure
head data set represented by the identifier `phead'.  The identifier  
of the data set created by this operation is returned upon successful 
completion.  

        
\item{\begin{verbatim}pfprintdata dataset\end{verbatim}}
This command executes `pfgetgrid' and `pfgetelt' in order to display
all the elements in the data set represented by the identifier
`dataset'.
        
        
\item{\begin{verbatim}pfprintdiff datasetp datasetq digits [zero]\end{verbatim}}
This command executes `pfdiffelt' and `pfmdiff' to print differences
to standard output.  The differences are printed one per line along
with the coordinates where they occur.  The last two lines displayed  
will show the point at which there is a minimum number of significant 
digits in the difference as well as the maximum absolute difference.
        
        
\item{\begin{verbatim}pfprintgrid dataset\end{verbatim}}
This command executes pfgetgrid and formats its output before printing
it on the screen.  The triples (nx, ny, nz), (x, y, z), and
(dx, dy, dz) are all printed on seperate lines along with labels
describing each.
        
        
\item{\begin{verbatim}pfprintlist [dataset]\end{verbatim}}
This command executes pflistdata and formats the output of that
command.  The formatted output is then printed on the screen.  The
output consists of a list of data sets and their labels one per line
if no argument was given or just one data set if an identifier was
given.
        
        
\item{\begin{verbatim}pfprintmdiff datasetp datasetq digits [zero]\end{verbatim}}
This command executes `pfmdiff' and formats that command's output
before displaying it on the screen.  Given the search criteria, a line
displaying the point at which the difference has the least number of
significant digits will be displayed.  Another line displaying the
maximum absolute difference will also be displayed.
 
        
\item{\begin{verbatim}printstats dataset\end{verbatim}}
This command executes `pfstats' and formats that command's output
before printing it on the screen.  Each of the values mentioned in the
description of `pfstats' will be displayed along with a label.


\item{\begin{verbatim}pfundist filename, pfundist runname\end{verbatim}}

The command undistributes a \parflow{} output file.  \parflow{} uses a
distributed file system where each node can write to its own file.
The pfundist command takes all of these individual files and collapses
them into a single file.

The arguments can be a runname or a filename.  If a runname is given
then all of the output files associated with that run are
undistributed.

Normally this is done after every pfrun command.
        
\end{description}        

%=============================================================================
%=============================================================================

\section{Directory of Test Cases}
\label{Test Directory}

\parflow{} comes with a directory containing a few simple input files for use
as templates in making new files and for use in testing the code.  This section
gives a brief description of the problems in this directory.

\begin{description}

\item{\file{crater2D.tcl} An example of a two-dimensional, variably-saturated crater infiltration prblem with time-varying boundary conditions.  It uses the solid file \file{crater2D.pfsol.}}

\item{\file{default_richards.tcl} The default variably-saturated Richards’ Equation simulation test script.}

\item{\file{default_single.tcl} The default parflow, single-processor, fully-saturated test script.}

\item{\file{forsyth2.tcl} An example two-dimensional, variably-saturated infiltration problem with layers of different hydraulic properties.  It uses the solid file \file{fors2_hf.pfsol}.}

\item{\file{harvey.flow.tcl} An example from \cite{MWH07} for the Cape Cod bacterial injection site.  This example is a three-dimensional, fully-saturated flow problem with spatially heterogeneous media (using a correlated, random field approach).  It also provides examples of how tcl/tk scripts may be used in conjunction with ParFlow to loop iteratively or to run other scripts or programs.  It uses the input text file \file{stats4.txt}. This input script is fully detailed in Section \ref{Tutorial} }

\item{\file{default_overland.tcl} An overland flow boundary condition test and example script based loosely on the V-catchment problem in \cite{KM06}.  There are options provided to expand this problem into other overland flow-type, transient boundary-type problems included in the file as well.}

\end{description}

%=============================================================================
%=============================================================================

\section{Annotated Input Script}
\label{Tutorial}

This tutorial matches the {\file harvey_flow.tcl} file found in the {\file /test} directory.  This example is directly from \cite{MWH07}.  This example demonstrates how to set up and run a fully saturated flow problem with heterogeneous hydraulic conductivity.  Given statistical parameters describing the geology of your site, this script can be easily modified to make as many realizations of the subsurface as you like, each different and yet having the same statistical parameters, useful for a Monte Carlo simulation.To run \parflow{}, you use a script written in Tcl/TK.  This script has a lot of flexibility, as it is somewhere in between a program and a user interface.  The tcl script gives \parflow{} the data it requires (or tells \parflow{} where to find or read in that data) and also tells \parflow{} to run.As stated above, the tcl script for the Cape Cod simulation is called {\file harvey.flow.tcl}When the script runs, it creates a new directory named {\file /flow} right in the directory where the tcl script is stored.  \parflow{} then puts all its output in {\file /flow}.  Of course, you can change the name and location of this output directory by modifying the tcl script that runs \parflow{}.To run the simulation:
\begin{enumerate}\item{make any modifications to the tcl input script (and give a new name, if you want to)}\item{save the tcl script}\item{For Windows: double click on it to run \parflow{}}
\item{For Linux/Unix/OSX: invoke the script from the command line using the tcl-shell, this looks like: { \file :>tclsh harvey_flow.tcl}}\item{wait patiently for a small empty square window to appear (Windows) or the command prompt to return (Linux/Unix/OSX) indicating that ParFlow has finished.  Intermediate files are written as the simulation runs, however there is no other indication that ParFlow is running.}\end{enumerate}
To modify a tcl script, you right-click and select “edit” from the menu.  If you select “open,” you will run the script.Note:  The units for K (m/d, usually) are critical to the entire construction.  These length and time units for K set the units for all other variables (input or generated, throughout the entire simulation) in the simulation.  ParFlow can set to solve using hydraulic conductivity by literally setting density, viscosity and gravity to one (as is done in the script below).  This means the pressure units are in length (meters), so pressure is now so-called pressure-head.Now for the tcl script:\begin{display}\begin{verbatim}## Import the ParFlow TCL package#\end{display}\end{verbatim}
These first three lines are what link Parflow and the tcl script, thus allowing you to use a set of commands seen later, such as “pfset,” etc.\begin{display}\begin{verbatim}lappend auto_path $env(PARFLOW_DIR)/bin package require parflownamespace import Parflow::*#----------------------------------------------------------------------------# File input version number#----------------------------------------------------------------------------pfset FileVersion 4\end{display}\end{verbatim}
These next lines set the parallel process topology.  The domain is divided in x,y and z by P, Q and R.  The total number of processors is P*Q*R.

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------# Process Topology#----------------------------------------------------------------------------pfset Process.Topology.P        1pfset Process.Topology.Q        1pfset Process.Topology.R        1\end{display}\end{verbatim}
Next we set up the computational grid (ParFlow manual §3.1).

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------# Computational Grid#----------------------------------------------------------------------------Locate the origin in the domain.pfset ComputationalGrid.Lower.X                0.0pfset ComputationalGrid.Lower.Y                0.0pfset ComputationalGrid.Lower.Z                 0.0Define the size of the domain grid block.  Length units, same as those on hydraulic conductivity.pfset ComputationalGrid.DX	                 0.34pfset ComputationalGrid.DY                      0.34pfset ComputationalGrid.DZ	                 0.038Define the number of grid blocks in the domain.pfset ComputationalGrid.NX                      50pfset ComputationalGrid.NY                      30pfset ComputationalGrid.NZ                      100\end{display}\end{verbatim}
This next piece is comparable to a pre-declaration of variables.  These will be areas in our domain geometry.  The regions themselves will be defined later.  You must always have one that is the name of your entire domain.  If you want subsections within your domain, you may declare these as well.  For Cape Cod, we have the entire domain, and also the 2 (upper and lower) permeability zones in the aquifer.

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------# The Names of the GeomInputs#----------------------------------------------------------------------------pfset GeomInput.Names "domain_input upper_aquifer_input lower_aquifer_input"

\end{display}\end{verbatim}
Now you characterize your domain that you just pre-declared to be a “box” – (see the manual §5.1.2), and you also give it a name, “domain.”
\begin{display}\begin{verbatim}

#----------------------------------------------------------------------------# Domain Geometry Input#----------------------------------------------------------------------------pfset GeomInput.domain_input.InputType            Boxpfset GeomInput.domain_input.GeomName             domain

\end{display}\end{verbatim}
Here, you set the limits in space for your entire domain.  The span from Lower.X to Upper.X will be equal to the product of ComputationalGrid.DX times ComputationalGrid.NX   Same for Y and Z (i.e. the number of grid elements times size of the grid element has to equal the size of the grid in each dimension).   The “Patches” command assigns names to the outside edges, because the domain is the limit of the problem in space.

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------# Domain Geometry#----------------------------------------------------------------------------pfset Geom.domain.Lower.X                        0.0 pfset Geom.domain.Lower.Y                        0.0pfset Geom.domain.Lower.Z                          0.0pfset Geom.domain.Upper.X                        17.0pfset Geom.domain.Upper.Y                        10.2pfset Geom.domain.Upper.Z                        3.8pfset Geom.domain.Patches "left right front back bottom top"

\end{display}\end{verbatim}
Just like domain geometry, you also set the limits in space for the individual components (upper and lower, as defined in the Names of GeomInputs pre-declaration).  There are no patches for these geometries as they are internal to the domain.

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------# Upper Aquifer Geometry Input#----------------------------------------------------------------------------pfset GeomInput.upper_aquifer_input.InputType            Boxpfset GeomInput.upper_aquifer_input.GeomName             upper_aquifer#----------------------------------------------------------------------------# Upper Aquifer Geometry#----------------------------------------------------------------------------pfset Geom.upper_aquifer.Lower.X                        0.0 pfset Geom.upper_aquifer.Lower.Y                        0.0pfset Geom.upper_aquifer.Lower.Z                        1.5pfset Geom.upper_aquifer.Upper.X                        17.0pfset Geom.upper_aquifer.Upper.Y                        10.2pfset Geom.upper_aquifer.Upper.Z                        1.5#----------------------------------------------------------------------------# Lower Aquifer Geometry Input#----------------------------------------------------------------------------pfset GeomInput.lower_aquifer_input.InputType            Boxpfset GeomInput.lower_aquifer_input.GeomName             lower_aquifer#----------------------------------------------------------------------------# Lower Aquifer Geometry#----------------------------------------------------------------------------pfset Geom.lower_aquifer.Lower.X                        0.0 pfset Geom.lower_aquifer.Lower.Y                        0.0pfset Geom.lower_aquifer.Lower.Z                        0.0pfset Geom.lower_aquifer.Upper.X                        17.0pfset Geom.lower_aquifer.Upper.Y                        10.2pfset Geom.lower_aquifer.Upper.Z                        1.5\end{display}\end{verbatim}
Now you add permeability data to the domain sections defined above (manual §5.1.8).  You can reassign values simply by re-stating them – there is no need to comment out or delete the previous version – the final statement is the only one that counts.

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------# Perm#----------------------------------------------------------------------------

\end{display}\end{verbatim}
Name the permeability regions you will describe.

\begin{display}\begin{verbatim}pfset Geom.Perm.Names "upper_aquifer lower_aquifer"

\end{display}\end{verbatim}
You can set, for example homogeneous, constant permeability, or you can generate a random field that meets your statistical requirements.  To define a constant permeability for the entire domain:

\begin{display}\begin{verbatim}#pfset Geom.domain.Perm.Type     Constant#pfset Geom.domain.Perm.Value    4.0

\end{display}\end{verbatim}
However, for Cape Cod, we didn’t want a constant permeability field, so we instead generated a random permeability field meeting our statistical parameters for each the upper and lower zones.  Third from the bottom is the “Seed.”  This is a random starting point to generate the K field.  Pick any largish ODD number.  First we do something tricky w/ tcl/TK.  We use the native commands within tcl to open a text file and read in locally set variables.  Note we use set here and not pfset.  One is a native tcl command, the other a ParFlow-specific command.  For this problem, we are linking the parameter estimation code, PEST to ParFlow.  PEST writes out the ascii file stats4.txt (also located in the /test directory) as the result of a calibration run.  Since we are not coupled to PEST in this example, we just read in the file and use the values to assign statistical properties.

\begin{display}\begin{verbatim}# we open a file, in this case from PEST to set upper and lower # kg and sigma#set fileId [open stats4.txt r 0600]set kgu [gets $fileId]set varu [gets $fileId]set kgl [gets $fileId]set varl [gets $fileId]close $fileId

\end{display}\end{verbatim}
Now we set the heterogeneous parameters for the Upper and Lower aquifers (§5.1.8).  Note the special section at the very end of this block where we reset the geometric mean and standard deviation to our values we read in from a file.  NOTE: ParFlow uses ? not ?2.

\begin{display}\begin{verbatim}pfset Geom.upper_aquifer.Perm.Type "TurnBands"pfset Geom.upper_aquifer.Perm.LambdaX  3.60pfset Geom.upper_aquifer.Perm.LambdaY  3.60pfset Geom.upper_aquifer.Perm.LambdaZ  0.19pfset Geom.upper_aquifer.Perm.GeomMean  112.00pfset Geom.upper_aquifer.Perm.Sigma   1.0pfset Geom.upper_aquifer.Perm.Sigma   0.48989794pfset Geom.upper_aquifer.Perm.NumLines 150pfset Geom.upper_aquifer.Perm.RZeta  5.0pfset Geom.upper_aquifer.Perm.KMax  100.0pfset Geom.upper_aquifer.Perm.DelK  0.2pfset Geom.upper_aquifer.Perm.Seed  33333pfset Geom.upper_aquifer.Perm.LogNormal Logpfset Geom.upper_aquifer.Perm.StratType Bottompfset Geom.lower_aquifer.Perm.Type "TurnBands"pfset Geom.lower_aquifer.Perm.LambdaX  3.60pfset Geom.lower_aquifer.Perm.LambdaY  3.60pfset Geom.lower_aquifer.Perm.LambdaZ  0.19pfset Geom.lower_aquifer.Perm.GeomMean  77.0pfset Geom.lower_aquifer.Perm.Sigma   1.0pfset Geom.lower_aquifer.Perm.Sigma   0.48989794pfset Geom.lower_aquifer.Perm.NumLines 150pfset Geom.lower_aquifer.Perm.RZeta  5.0pfset Geom.lower_aquifer.Perm.KMax  100.0pfset Geom.lower_aquifer.Perm.DelK  0.2pfset Geom.lower_aquifer.Perm.Seed  33333pfset Geom.lower_aquifer.Perm.LogNormal Logpfset Geom.lower_aquifer.Perm.StratType Bottom#pfset lower aqu and upper aq stats to pest/read in valuespfset Geom.upper_aquifer.Perm.GeomMean  $kgupfset Geom.upper_aquifer.Perm.Sigma  $varupfset Geom.lower_aquifer.Perm.GeomMean  $kglpfset Geom.lower_aquifer.Perm.Sigma  $varl

\end{display}\end{verbatim}
The following section allows you to specify the permeability tensor.  In the case below, permeability is symmetric in all directions (x, y, and z) and therefore each is set to 1.0.

\begin{display}\begin{verbatim}pfset Perm.TensorType               TensorByGeompfset Geom.Perm.TensorByGeom.Names  "domain"pfset Geom.domain.Perm.TensorValX  1.0pfset Geom.domain.Perm.TensorValY  1.0pfset Geom.domain.Perm.TensorValZ  1.0

\end{display}\end{verbatim}
Next we set the specific storage, though this is not used in the IMPES/steady-state calculation.

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------# Specific Storage#----------------------------------------------------------------------------# specific storage does not figure into the impes (fully sat) case but we# still# need a key for itpfset SpecificStorage.Type            Constantpfset SpecificStorage.GeomNames       ""pfset Geom.domain.SpecificStorage.Value 1.0e-4

\end{display}\end{verbatim}
Parflow has the capability to deal with a multiphase system, but we only have one (water) at Cape Cod.  As we stated earlier, we set density and viscosity artificially (and later gravity) both to 1.0.  Again, this is merely a trick to solve for hydraulic conductivity and pressure head.  If you were to set density and viscosity to their true values, the code would calculate k (permeability).  By using the “normalized” values instead, you effectively imbed the conversion of k to K (hydraulic conductivity).  So this way, we get hydraulic conductivity, which is what we want for Cape Cod.

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------# Phases#----------------------------------------------------------------------------pfset Phase.Names "water"pfset Phase.water.Density.Type	Constantpfset Phase.water.Density.Value	1.0pfset Phase.water.Viscosity.Type	Constantpfset Phase.water.Viscosity.Value	1.0\end{display}\end{verbatim}
Leave contaminants blank b/c we’ll use a different code for to model (virus, tracer) contamination.

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------# Contaminants#----------------------------------------------------------------------------pfset Contaminants.Names			""

\end{display}\end{verbatim}
As with density and viscosity, gravity is normalized here.  If we used the true value (in the [L] and [T] units of hydraulic conductivity!) the code would be calculating permeability.  Instead, we normalize so that the code calculates hydraulic conductivity.

\begin{display}\begin{verbatim}
#----------------------------------------------------------------------------# Gravity#----------------------------------------------------------------------------pfset Gravity				1.0#----------------------------------------------------------------------------# Setup timing info#----------------------------------------------------------------------------

\end{display}\end{verbatim}

This basic time unit of 1.0 is used for transient boundary and well conditions.  We are not using those features in this example.

\begin{display}\begin{verbatim} pfset TimingInfo.BaseUnit		1.0

\end{display}\end{verbatim}
Cape Cod is a steady state problem, so these timing features are again unused, but need to be included.

\begin{display}\begin{verbatim}pfset TimingInfo.StartCount		-1pfset TimingInfo.StartTime		0.0pfset TimingInfo.StopTime            0.0

\end{display}\end{verbatim}
Set the “dump interval” to -1 to report info at the end of every calculation, which in this case is only when steady state has been reached.

\begin{display}\begin{verbatim}pfset TimingInfo.DumpInterval	       -1

\end{display}\end{verbatim}
Next, we assign the porosity (§5.1.9).  For the Cape Cod, the porosity is 0.39.  
\begin{display}\begin{verbatim}

#----------------------------------------------------------------------------# Porosity#----------------------------------------------------------------------------pfset Geom.Porosity.GeomNames          domainpfset Geom.domain.Porosity.Type    Constantpfset Geom.domain.Porosity.Value   0.390

\end{display}\end{verbatim}
Having defined the geometry of our problem before and named it “domain”, we’re now ready to report/upload that problem, which we do here.

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------# Domain#----------------------------------------------------------------------------pfset Domain.GeomName domainMobility between phases is set to 1.0 because we only have one phase (water).

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------# Mobility#----------------------------------------------------------------------------pfset Phase.water.Mobility.Type        Constantpfset Phase.water.Mobility.Value       1.0\end{display}\end{verbatim}
Again, Parflow has more capabilities that we are using for Cape Cod.  We will deal with our monitoring wells in a separate code as we assume the do not remove a significant amount of water from the domain.  Note that since there are no well names listed here, ParFlow assumes we have no wells.  If we had pumping wells, we would have to include them here, because they would affect the head distribution throughout our domain.

\begin{display}\begin{verbatim}

#----------------------------------------------------------------------------# Wells#----------------------------------------------------------------------------pfset Wells.Names ""\end{display}\end{verbatim}
You can give certain periods of time names if you want to (ie. Pre-injection, post-injection, etc) but we don’t have multiple time intervals and we’re steady state, so keep it simple.  We have only one time cycle and it’s constant for the duration of the simulation.  We accomplish this by giving it a repeat value of -1, which repeats indefinitely.  The length of the cycle is the length specified below (an integer) multiplied by the base unit value we specified earlier.

\begin{display}\begin{verbatim}

#----------------------------------------------------------------------------# Time Cycles#----------------------------------------------------------------------------pfset Cycle.Names constantpfset Cycle.constant.Names		"alltime"pfset Cycle.constant.alltime.Length	 1pfset Cycle.constant.Repeat		-1\end{display}\end{verbatim}
Now, we assign Boundary Conditions for each face (each of the Patches in the domain defined before).  Recall the previously stated Patches and associate them w/the boundary conditions that follow.

\begin{display}\begin{verbatim}pfset BCPressure.PatchNames "left right front back bottom top"

\end{display}\end{verbatim}
These are Dirichelet BCs (i.e. constant head over cell so the pressure head is set to hydrostatic), see manual §5.1.17.  There is no time dependence, so use the “constant” time cycle we defined previously.  “RefGeom” links this to the established domain geometry and tells ParFlow what to use for a datum when calculating hydrostatic head conditions.

\begin{display}\begin{verbatim}pfset Patch.left.BCPressure.Type			DirEquilRefPatchpfset Patch.left.BCPressure.Cycle			"constant"pfset Patch.left.BCPressure.RefGeom			domainReference the current (left) patch to the bottom to define the line of intersection between the two.

\begin{display}\begin{verbatim}pfset Patch.left.BCPressure.RefPatch			bottom

\end{display}\end{verbatim}
Set the head permanently to 10.0m.  (pressure head will of course vary top to bottom b/c of hydrostatics, but head will be constant).

\begin{display}\begin{verbatim}pfset Patch.left.BCPressure.alltime.Value		10.0

\end{display}\end{verbatim}
Repeat the declarations for the rest of the faces of the domain.  The left to right (x) dimension is aligned with the hydraulic gradient.  The difference between the values assigned to right and left divided by the length of the domain corresponds to the correct hydraulic gradient.

\begin{display}\begin{verbatim}
pfset Patch.right.BCPressure.Type			DirEquilRefPatchpfset Patch.right.BCPressure.Cycle			"constant"pfset Patch.right.BCPressure.RefGeom			domainpfset Patch.right.BCPressure.RefPatch			bottompfset Patch.right.BCPressure.alltime.Value		9.97501pfset Patch.front.BCPressure.Type			FluxConstpfset Patch.front.BCPressure.Cycle			"constant"pfset Patch.front.BCPressure.alltime.Value		0.0pfset Patch.back.BCPressure.Type			FluxConstpfset Patch.back.BCPressure.Cycle			"constant"pfset Patch.back.BCPressure.alltime.Value		0.0pfset Patch.bottom.BCPressure.Type			FluxConstpfset Patch.bottom.BCPressure.Cycle			"constant"pfset Patch.bottom.BCPressure.alltime.Value		0.0pfset Patch.top.BCPressure.Type			FluxConstpfset Patch.top.BCPressure.Cycle			"constant"pfset Patch.top.BCPressure.alltime.Value		0.0\end{display}\end{verbatim}
Next we define topographic slopes and Mannings n values.  These are not used, since we do not solve for overland flow.  However, the keys still need to appear in the input script.

\begin{display}\begin{verbatim}

#---------------------------------------------------------# Topo slopes in x-direction#---------------------------------------------------------# topo slopes do not figure into the impes (fully sat) case but we still# need keys for thempfset TopoSlopesX.Type "Constant"pfset TopoSlopesX.GeomNames ""pfset TopoSlopesX.Geom.domain.Value 0.0#---------------------------------------------------------# Topo slopes in y-direction#---------------------------------------------------------pfset TopoSlopesY.Type "Constant"pfset TopoSlopesY.GeomNames ""pfset TopoSlopesY.Geom.domain.Value 0.0#---------------------------------------------------------# Mannings coefficient #---------------------------------------------------------# mannings roughnesses do not figure into the impes (fully sat) case but we still# need a key for thempfset Mannings.Type "Constant"pfset Mannings.GeomNames ""pfset Mannings.Geom.domain.Value 0.\end{display}\end{verbatim}
Phase sources allows you to add sources other than wells and boundaries, but we don’t have any so it’s constant, 0.0 over entire domain.
\begin{display}\begin{verbatim}

#----------------------------------------------------------------------------# Phase sources:#----------------------------------------------------------------------------pfset PhaseSources.water.Type                         Constantpfset PhaseSources.water.GeomNames                    domainpfset PhaseSources.water.Geom.domain.Value        0.0\end{display}\end{verbatim}
Next we define solver parameters for IMPES.  Since this is the default solver, we do not need a solver key.

\begin{display}\begin{verbatim}#----------------------------------------------------------------------------#  Solver Impes  #----------------------------------------------------------------------------
\end{display}\end{verbatim}

We allow up to 50 iterations of the linear solver before it quits or converges.

\begin{display}\begin{verbatim} pfset Solver.MaxIter 50The solution must be accurate to this level 

\begin{display}\begin{verbatim}pfset Solver.AbsTol  1E-10

\end{display}\end{verbatim}
We drop significant digits beyond E-15

\begin{display}\begin{verbatim}pfset Solver.Drop   1E-15#----------------------------------------------------------------------------# Run and Unload the ParFlow output files#----------------------------------------------------------------------------\end{display}\end{verbatim}
Here you set the number of realizations again using a local tcl variable.  We have set only 1 runs but by setting the n_runs variable to something else we can run more than one realization of hydraulic conductivity. 
\begin{display}\begin{verbatim}
# this script is setup to run 100 realizations, for testing we just run one###set n_runs 100set n_runs 1

\end{display}\end{verbatim}
Here is where you tell ParFlow where to put the output.  In this case, it’s a directory called flow.  Then you cd (change directory) into that new directory.  If you wanted to put an entire path rather than just a name, you would have more control over where your output file goes.  For example, you would put    {\file file mkdir “C:/cape_cod/revised_statistics/flow"} and then change into that directory.  Note that for Windows you must use a DOUBLE backslash in the file path; the single backslash is a control character. (The single forward slash, however, works fine – I think.)

\begin{display}\begin{verbatim}file mkdir "flow"cd "flow"

\end{display}\end{verbatim}
Now we loop through the realizations, again using tcl.  k is the integer counter that is incremented for each realization.  When you use a variable (rather than define it), you precede it with $.  The hanging character “{“ opens the do loop for k.

\begin{display}\begin{verbatim}##  Loop through runs#for {set k 1} {$k <= $n_runs} {incr k 1} {

\end{display}\end{verbatim}
The following expressions sets the variable “seed” equal to the expression in brackets, which increments with each turn of the do loop – and each seed will produce a different random field of Ks.  You set upper and lower aquifer, b/c in the Cape Cod site, these are the two subsets of the domain.  Note the seed starts at a different point b/c you don’t want the same two random generations for the upper and lower zones.

\begin{display}\begin{verbatim}## set the random seed to be different for every run#pfset Geom.upper_aquifer.Perm.Seed  [ expr 33333+2*$k ] pfset Geom.lower_aquifer.Perm.Seed  [ expr 31313+2*$k ]

\end{display}\end{verbatim}

The following command runs ParFlow and gives you a suite of output files for each realization.  The file names will begin {\file harvey_flow.1.xxxxx} , {\file harvey_flow.2.xxxx}, etc up to as many realizations as you run.  The “.xxxxx” part will designate x, y, and z permeability, etc.  (Except that in this case, since we normalized gravity, viscosity, and density, remember that we’re really getting hydraulic conductivity.)

\begin{display}\begin{verbatim}pfrun harvey_flow.$k

\end{display}\end{verbatim}
This command removes a large number of superfluous dummy files.

\begin{display}\begin{verbatim}
pfundist harvey_flow.$k

\end{display}\end{verbatim}
The following commands take advantage of PFTools (manual §3.6.2) and load pressure head output of the Parflow model into a pressure matrix.

\begin{display}\begin{verbatim}# we use pf tools to convert from pressure to head# we could do a number of other things here like copy files to different# formatset press [pfload harvey_flow.$k.out.press.pfb]\end{display}\end{verbatim}
The next command takes the pressures that were just loaded and converts it to head and loads them into a head matrix tcl variable.

\begin{display}\begin{verbatim}set head [pfhhead $press]\end{display}\end{verbatim}
Finally, the head matrix is saved as a ParFlow binary file (.pfb) and the k do loop is closed by the “}” character.  The we move up to the root directory when we are finished

\begin{display}\begin{verbatim} pfsave $head -pfb harvey_flow.$k.head.pfb}cd ".."\end{display}\end{verbatim}
Once you have modified the tcl input script (if necessary) and run ParFlow, you will have as many realizations of your subsurface as you specified.  Each of these realizations will be used as input for a particle or streamline calculation in the future.  We can see below, that since we have a tcl script as input, we can do a lot of different operations, for example, we might run a particle tracking transport code simulation using the results of the ParFlow runs.  This actually corresponds to the example presented in the SLIM_FAST (Maxwell and Tompson, 2006) user’s manual.

\begin{display}\begin{verbatim}# this could run other tcl scripts now an example is below#puts stdout "running SLIM"#source bromide_trans.sm.tcl\end{display}\end{verbatim}
We could also visualize the results of the ParFlow simulations, using a number of codes.  For example, if we used chunk to create visual representations of your results, the file harvey_flow.#.out.perm_x.pfb (where # is the realization number) will be the “field” of your domain, showing the variation in x-permeability in 3-D space.  You can also generate representations of head or pressure (or y or z permeability) throughout your domain using parflow output files.  See the section on Chunk for more details.\bigskip

%============
%============